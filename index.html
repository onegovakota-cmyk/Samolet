<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Catch the Answer</title>

<style>
  :root{
    --bg: transparent;
    --text: rgba(255,255,255,.92);
    --muted: rgba(255,255,255,.72);

    --panel-bg: rgba(10,10,20,.55);
    --panel-brd: rgba(255,255,255,.14);
    --shadow: 0 14px 50px rgba(0,0,0,.35);

    --accent: rgba(120,90,255,.95);
    --answer: rgba(255,255,255,.16);   /* –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π —Ü–≤–µ—Ç –¥–ª—è –≤—Å–µ—Ö –æ—Ç–≤–µ—Ç–æ–≤ */
    --answer-brd: rgba(255,255,255,.18);
    --answer-text: rgba(255,255,255,.92);

    --good: #4cff9e;
    --bad:  #ff6b6b;

    --size: 58px;      /* –∏–≥—Ä–æ–∫ –∏ –æ—Ç–≤–µ—Ç—ã –æ–¥–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ */
    --radius: 18px;
  }

  html,body{
    margin:0;height:100%;
    background: var(--bg) !important;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    color:var(--text);
    overflow:hidden;
  }

  #game{position:relative;width:100%;height:100%;}

  /* HUD */
  #hud{
    position:absolute;
    top:12px; left:12px; right:12px;
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap:12px;
    z-index:20;
    pointer-events:none;
  }

  /* Score box (left-top) */
  .scoreBox{
    pointer-events:none;
    background: var(--panel-bg);
    border: 1px solid var(--panel-brd);
    border-radius: 999px;
    padding: 10px 12px;
    box-shadow: var(--shadow);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    display:flex;
    gap:10px;
    align-items:center;
    min-width: 110px;
  }
  .scoreBox .label{
    font-size:12px;
    color: var(--muted);
    font-weight:900;
    letter-spacing:.2px;
  }
  .scoreBox .value{
    font-size:16px;
    font-weight:1100;
    color: var(--text);
  }

  /* Lives (right-top, minimal) */
  .livesBox{
    pointer-events:none;
    background: var(--panel-bg);
    border: 1px solid var(--panel-brd);
    border-radius: 999px;
    padding: 10px 12px;
    box-shadow: var(--shadow);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    font-size:14px;
    font-weight:1000;
    color: var(--text);
    white-space:nowrap;
  }

  /* Question centered */
  #questionWrap{
    position:absolute;
    top:12px;
    left:50%;
    transform:translateX(-50%);
    z-index:21;
    pointer-events:none;
    max-width:min(860px, calc(100% - 24px));
  }
  #questionBox{
    background: var(--panel-bg);
    border: 1px solid var(--panel-brd);
    border-radius: 999px;
    padding: 12px 16px;
    box-shadow: var(--shadow);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    text-align:center;
    font-weight:1000;
    font-size:14px;
    letter-spacing:.2px;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }

  /* Scene */
  #scene{position:absolute; inset:0; overflow:hidden;}

  /* Player + Answers */
  .orb{
    position:absolute;
    width: var(--size);
    height: var(--size);
    border-radius: 50%;
    display:flex;
    align-items:center;
    justify-content:center;
    user-select:none;
  }

  #player{
    left:72px;
    top:50%;
    transform:translate(-50%,-50%);
    background: rgba(120,90,255,.22);
    border: 1px solid rgba(120,90,255,.35);
    box-shadow: 0 12px 35px rgba(0,0,0,.25), 0 0 22px rgba(120,90,255,.25);
  }
  #player:before{
    content:"";
    width: 18px;
    height: 18px;
    border-radius: 999px;
    background: rgba(255,255,255,.85);
    box-shadow: 0 0 12px rgba(255,255,255,.25);
  }

  .answer{
    background: var(--answer);
    border: 1px solid var(--answer-brd);
    box-shadow: 0 14px 45px rgba(0,0,0,.28);
    color: var(--answer-text);
    font-weight:1100;
    font-size:18px;
    letter-spacing:.5px;
  }

  /* Pop +points */
  .pop{
    position:absolute;
    font-weight:1100;
    font-size:18px;
    pointer-events:none;
    transform:translate(-50%,-50%);
    text-shadow: 0 14px 30px rgba(0,0,0,.5);
    animation: popUp .78s ease-out forwards;
    z-index:30;
  }
  @keyframes popUp{
    0%   { opacity:0; transform:translate(-50%,-50%) scale(.9); filter:blur(.2px); }
    15%  { opacity:1; transform:translate(-50%,-62%) scale(1.05); filter:blur(0); }
    100% { opacity:0; transform:translate(-50%,-105%) scale(1.0); }
  }

  /* Feedback center (subtle) */
  #feedback{
    position:absolute; inset:0;
    display:flex; align-items:center; justify-content:center;
    font-size:30px; font-weight:1100;
    pointer-events:none;
    opacity:0;
    transition:.18s;
    z-index:25;
  }
  #feedback.show{ opacity:1; }

  /* Final overlay */
  #final{
    position:absolute; inset:0;
    background: rgba(0,0,0,.78);
    display:none;
    align-items:center; justify-content:center;
    flex-direction:column;
    gap:14px;
    z-index:40;
    text-align:center;
    padding:20px;
  }
  #final.show{ display:flex; }
  #final h1{ margin:0; font-size:30px; }
  #final .small{ opacity:.8; max-width:560px; line-height:1.4; font-size:13px; }
  #final button{
    pointer-events:auto;
    padding:10px 16px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.18);
    background: rgba(255,255,255,.10);
    color: rgba(255,255,255,.92);
    font-weight:1000;
    cursor:pointer;
  }
  #final button:hover{ background: rgba(255,255,255,.14); }

  /* tiny hint bottom (optional) */
  #hint{
    position:absolute;
    left:50%;
    bottom:10px;
    transform:translateX(-50%);
    font-size:12px;
    opacity:.55;
    pointer-events:none;
    z-index:5;
  }
</style>
</head>

<body>
<div id="game">

  <div id="hud">
    <div class="scoreBox">
      <div class="label">–û—á–∫–∏</div>
      <div class="value" id="score">0</div>
    </div>

    <div class="livesBox" id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
  </div>

  <div id="questionWrap">
    <div id="questionBox">‚Äî</div>
  </div>

  <div id="scene">
    <div class="orb" id="player"></div>
  </div>

  <div id="feedback"></div>

  <div id="final">
    <h1 id="finalTitle">‚Äî</h1>
    <div class="small" id="finalText"></div>
    <button onclick="restart()">–ò–≥—Ä–∞—Ç—å –µ—â—ë</button>
  </div>

  <div id="hint">‚¨Ü / ‚¨á —á—Ç–æ–±—ã –¥–≤–∏–≥–∞—Ç—å—Å—è</div>
</div>

<script>
/* ================= CONFIG (–ø–æ–¥ –±—É–¥—É—â–∏–π —Ä–µ–¥–∞–∫—Ç–æ—Ä) ================= */
const GAME_CONFIG = {
  lives: 3,
  speed: 3.0,
  playerSpeed: 7,
  feedbackMs: 420,

  scoring: {
    pointsPerCorrect: 10,
    popColor: "#4cff9e",
    popText: (pts)=>`+${pts}`, // –Ω–∞ –±—É–¥—É—â–µ–µ –ø–æ–¥ –ª–æ–∫–∞–ª–∏–∑–∞—Ü–∏—é
  },

  layout: {
    paddingTop: 92,    // —É—á–∏—Ç—ã–≤–∞–µ–º HUD/–≤–æ–ø—Ä–æ—Å
    paddingBottom: 34,
    minDistY: 88,
    startX: 120,
    xSpreadMin: 110,
    xSpreadMax: 190,
  },

  // –≤–æ–ø—Ä–æ—Å—ã/–æ—Ç–≤–µ—Ç—ã. correct —Å–∫—Ä—ã—Ç –≤–∏–∑—É–∞–ª—å–Ω–æ, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ª–æ–≥–∏–∫–æ–π.
  questions: [
    {
      q: "–°—Ç–æ–ª–∏—Ü–∞ –§—Ä–∞–Ω—Ü–∏–∏?",
      answers: [
        { label:"A", correct:false },
        { label:"B", correct:true  },
        { label:"C", correct:false }
      ]
    },
    {
      q: "2 + 2 = ?",
      answers: [
        { label:"A", correct:false },
        { label:"B", correct:true  },
        { label:"C", correct:false }
      ]
    },
    {
      q: "–ì–¥–µ –±–æ–ª—å—à–µ: 7 –∏–ª–∏ 9?",
      answers: [
        { label:"A", correct:false },
        { label:"B", correct:true  },
        { label:"C", correct:false }
      ]
    },
  ],
};
/* ================================================================ */

const scene = document.getElementById("scene");
const player = document.getElementById("player");
const questionBox = document.getElementById("questionBox");
const scoreEl = document.getElementById("score");
const livesEl = document.getElementById("lives");
const feedback = document.getElementById("feedback");
const final = document.getElementById("final");
const finalTitle = document.getElementById("finalTitle");
const finalText = document.getElementById("finalText");

let keys = {};
let raf = null;
let state = null;

function initState(){
  state = {
    qIndex: 0,
    lives: GAME_CONFIG.lives,
    score: 0,
    active: [],
    locked: false,
  };
}

function hearts(n){
  return "‚ù§Ô∏è".repeat(Math.max(0,n)) + (n<=0 ? "‚Äî" : "");
}

function updateHUD(){
  scoreEl.textContent = String(state.score);
  livesEl.textContent = hearts(state.lives);

  if(state.qIndex < GAME_CONFIG.questions.length){
    questionBox.textContent = GAME_CONFIG.questions[state.qIndex].q;
  } else {
    questionBox.textContent = "";
  }
}

function clearAnswers(){
  state.active.forEach(o=>o.el.remove());
  state.active = [];
}

function randInt(a,b){
  return Math.floor(a + Math.random() * (b - a + 1));
}

function spawnAnswersForQuestion(){
  clearAnswers();
  const q = GAME_CONFIG.questions[state.qIndex];
  const L = GAME_CONFIG.layout;

  const usedY = [];
  const startX = scene.clientWidth + L.startX;

  function pickY(){
    const minY = L.paddingTop;
    const maxY = scene.clientHeight - L.paddingBottom;
    for(let attempt=0; attempt<40; attempt++){
      const y = randInt(minY, maxY);
      const ok = usedY.every(prev => Math.abs(prev - y) >= L.minDistY);
      if(ok){ usedY.push(y); return y; }
    }
    const fallback = randInt(minY, maxY);
    usedY.push(fallback);
    return fallback;
  }

  // –ø–µ—Ä–µ—Ç–∞—Å—É–µ–º –ø–æ–∑–∏—Ü–∏–∏, —á—Ç–æ–±—ã –±—É–∫–≤—ã –Ω–µ –±—ã–ª–∏ –≤—Å–µ–≥–¥–∞ —Å–≤–µ—Ä—Ö—É/—Å–Ω–∏–∑—É –æ–¥–∏–Ω–∞–∫–æ–≤–æ
  const shuffled = [...q.answers].sort(()=>Math.random()-0.5);

  shuffled.forEach((a,i)=>{
    const el = document.createElement("div");
    el.className = "orb answer";
    el.textContent = a.label;
    el.dataset.correct = a.correct ? "1" : "0";

    const xOffset = i * randInt(L.xSpreadMin, L.xSpreadMax);
    el.style.left = (startX + xOffset) + "px";
    el.style.top  = pickY() + "px";
    el.style.transform = "translate(-50%,-50%)";

    scene.appendChild(el);
    state.active.push({ el, data:a, hit:false });
  });
}

function showFeedback(text, ok){
  feedback.textContent = text;
  feedback.style.color = ok ? "var(--good)" : "var(--bad)";
  feedback.classList.add("show");
  setTimeout(()=>feedback.classList.remove("show"), Math.max(120, GAME_CONFIG.feedbackMs - 80));
}

function showPointsPop(x,y,points){
  const pop = document.createElement("div");
  pop.className = "pop";
  pop.textContent = GAME_CONFIG.scoring.popText(points);
  pop.style.color = GAME_CONFIG.scoring.popColor;
  pop.style.left = x + "px";
  pop.style.top = y + "px";
  scene.appendChild(pop);
  setTimeout(()=>pop.remove(), 900);
}

function endGame(win){
  state.locked = true;
  clearAnswers();
  updateHUD();

  final.classList.add("show");
  finalTitle.textContent = win ? "üéâ –û—Ç–ª–∏—á–Ω–æ!" : "üíÄ –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞";
  const total = GAME_CONFIG.questions.length;
  const answered = Math.min(state.qIndex, total);
  finalText.textContent = `–¢—ã –ø—Ä–æ—à—ë–ª(–ª–∞) ${answered}/${total} –≤–æ–ø—Ä–æ—Å–æ–≤. –û—á–∫–∏: ${state.score}.`;

  if(raf) cancelAnimationFrame(raf);
  raf = null;
}

function goNextQuestion(){
  state.qIndex++;
  if(state.lives <= 0){ endGame(false); return; }
  if(state.qIndex >= GAME_CONFIG.questions.length){ endGame(true); return; }
  state.locked = false;
  updateHUD();
  spawnAnswersForQuestion();
}

function handleAnswer(correct, hitX, hitY){
  if(state.locked) return;
  state.locked = true;

  // —É–±—Ä–∞—Ç—å –æ—Å—Ç–∞–ª—å–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –ø–æ–≤—Ç–æ—Ä–Ω—ã—Ö –ø–æ–ø–∞–¥–∞–Ω–∏–π
  clearAnswers();

  if(correct){
    const pts = GAME_CONFIG.scoring.pointsPerCorrect;
    state.score += pts;
    updateHUD();
    showPointsPop(hitX, hitY, pts);
    showFeedback("–í–µ—Ä–Ω–æ", true);
  } else {
    state.lives--;
    updateHUD();
    showFeedback("–ù–µ–≤–µ—Ä–Ω–æ", false);

    // –ª—ë–≥–∫–∞—è ‚Äú–≤–∏–±—Ä–∞—Ü–∏—è‚Äù
    player.animate(
      [{transform:"translate(-50%,-50%)"},
       {transform:"translate(-50%,-50%) translateX(-4px)"},
       {transform:"translate(-50%,-50%) translateX(4px)"},
       {transform:"translate(-50%,-50%)"}],
      {duration:220}
    );
  }

  // –∏–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è
  setTimeout(goNextQuestion, GAME_CONFIG.feedbackMs);
}

function checkCollision(obj){
  if(obj.hit || state.locked) return;

  const a = obj.el.getBoundingClientRect();
  const p = player.getBoundingClientRect();
  const overlap = !(a.right < p.left || a.left > p.right || a.bottom < p.top || a.top > p.bottom);

  if(overlap){
    obj.hit = true;
    const sceneRect = scene.getBoundingClientRect();
    const hitX = (a.left + a.right)/2 - sceneRect.left;
    const hitY = (a.top + a.bottom)/2 - sceneRect.top;

    obj.el.remove();
    handleAnswer(obj.data.correct === true, hitX, hitY);
  }
}

function loop(){
  if(!state) return;

  // player move
  const step = GAME_CONFIG.playerSpeed;
  let y = player.offsetTop;
  if(keys.ArrowUp) y -= step;
  if(keys.ArrowDown) y += step;
  y = Math.max(0, Math.min(scene.clientHeight - player.clientHeight, y));
  player.style.top = y + "px";

  // answers move
  if(!state.locked){
    state.active.forEach(obj=>{
      const x = obj.el.offsetLeft - GAME_CONFIG.speed;
      obj.el.style.left = x + "px";
      checkCollision(obj);
    });
  }

  raf = requestAnimationFrame(loop);
}

function restart(){
  final.classList.remove("show");
  if(raf) cancelAnimationFrame(raf);
  raf = null;

  initState();
  updateHUD();
  player.style.top = Math.round(scene.clientHeight/2) + "px";
  spawnAnswersForQuestion();
  loop();
}

// controls
window.addEventListener("keydown", (e)=>{ keys[e.key]=true; });
window.addEventListener("keyup", (e)=>{ keys[e.key]=false; });

// start
initState();
updateHUD();
player.style.top = "50%";
spawnAnswersForQuestion();
loop();
</script>
</body>
</html>
