<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Genially Game</title>
  <link rel="icon" href="data:,">

  <style>
    :root{
      --bg: transparent;

      --panel-bg: rgba(10,10,20,.60);
      --panel-brd: rgba(255,255,255,.18);
      --shadow: 0 16px 60px rgba(0,0,0,.42);

      --answer-bg: rgba(20, 18, 34, .82);
      --answer-brd: rgba(255,255,255,.22);
      --answer-text: rgba(255,255,255,.98);

      --player-bg: rgba(120,90,255,.22);
      --player-brd: rgba(120,90,255,.40);

      --good: #4cff9e;
      --bad:  #ff6b6b;
      --neon-yellow: #ffd84a;

      --size: 86px;
    }

    html,body{margin:0;height:100%;background:var(--bg)!important;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;overflow:hidden;}
    #game{position:relative;width:100%;height:100%;}

    #topbar{
      position:absolute; top:12px; left:12px; right:12px;
      display:flex; align-items:flex-start; justify-content:space-between;
      gap:12px;
      z-index:120;
      pointer-events:none;
    }
    .pill{
      background: var(--panel-bg);
      border: 1px solid var(--panel-brd);
      border-radius: 999px;
      padding: 10px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display:flex; gap:10px; align-items:center;
      white-space:nowrap;
      color: rgba(255,255,255,.92);
      pointer-events:none;
    }
    .pill .label{font-size:12px;color:rgba(255,255,255,.72);font-weight:900}
    .pill .value{font-size:16px;font-weight:1100}

    #questionWrap{
      position:absolute; top:62px; left:50%; transform:translateX(-50%);
      z-index:110; pointer-events:none;
      max-width:min(900px, calc(100% - 24px));
    }
    #questionBox{
      background: var(--panel-bg);
      border: 1px solid var(--panel-brd);
      border-radius: 999px;
      padding: 12px 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      text-align:center;
      font-weight:1100;
      font-size:14px;
      color: rgba(255,255,255,.92);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }

    #scene{position:absolute; inset:0; overflow:hidden;}

    .orb{
      position:absolute;
      width: var(--size);
      height: var(--size);
      border-radius: 50%;
      display:flex; align-items:center; justify-content:center;
      user-select:none;
    }

    #player{
      left:92px; top:50%;
      transform:translate(-50%,-50%);
      background: var(--player-bg);
      border: 1px solid var(--player-brd);
      box-shadow: 0 12px 40px rgba(0,0,0,.28), 0 0 26px rgba(120,90,255,.25);
    }
    #player:before{
      content:"";
      width:18px;height:18px;border-radius:999px;
      background: rgba(255,255,255,.88);
      box-shadow:0 0 14px rgba(255,255,255,.25);
    }

    .answer{
      background: var(--answer-bg);
      border: 1px solid var(--answer-brd);
      box-shadow: 0 16px 55px rgba(0,0,0,.35);
      color: var(--answer-text);
      padding: 10px 10px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      gap:6px;
    }
    .answer .lab{
      font-weight:1200;
      font-size:18px;
      line-height:1;
      letter-spacing:.8px;
      text-shadow: 0 10px 22px rgba(0,0,0,.55);
      -webkit-text-stroke: 0.35px rgba(0,0,0,.35);
    }
    .answer .txt{
      font-weight:1100;
      font-size:13px;
      line-height:1.12;
      max-width: 180px;
      white-space:normal;
      word-break:break-word;
      padding: 4px 8px;
      border-radius: 10px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      text-shadow: 0 10px 22px rgba(0,0,0,.55);
      -webkit-text-stroke: 0.35px rgba(0,0,0,.35);
    }

    .pop{
      position:absolute;
      font-weight:1300;
      font-size:20px;
      pointer-events:none;
      transform:translate(-50%,-50%);
      color: var(--neon-yellow);
      text-shadow:
        0 0 10px rgba(255,216,74,.90),
        0 0 24px rgba(255,216,74,.70),
        0 16px 36px rgba(0,0,0,.55);
      animation: popUp .78s ease-out forwards;
      z-index:140;
    }
    @keyframes popUp{
      0%{opacity:0;transform:translate(-50%,-50%) scale(.9);}
      15%{opacity:1;transform:translate(-50%,-62%) scale(1.05);}
      100%{opacity:0;transform:translate(-50%,-112%) scale(1);}
    }

    #feedback{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      font-size:30px; font-weight:1200;
      pointer-events:none;
      opacity:0; transition:.18s;
      z-index:130;
      text-shadow: 0 16px 36px rgba(0,0,0,.55);
      color: rgba(255,255,255,.92);
    }
    #feedback.show{opacity:1;}

    #progressWrap{
      position:absolute; left:12px; right:12px; bottom:12px;
      z-index:115; pointer-events:none;
    }
    #progressBar{
      height: 20px;
      border-radius: 999px;
      background: rgba(0,0,0,.14);
      border: 1px solid rgba(255,255,255,.22);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #progressFill{
      height:100%;
      width:0%;
      background: rgba(120,90,255,.72);
      border-radius:999px;
      transition: width .25s ease;
    }
    #progressText{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      font-size:12px; font-weight:1200;
      color: rgba(255,255,255,.96);
      text-shadow:0 10px 22px rgba(0,0,0,.5);
    }

    .overlay{
      position:absolute; inset:0;
      display:none;
      align-items:center; justify-content:center;
      z-index:300;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      pointer-events:auto;
    }
    .overlay.show{display:flex;}

    .card{
      width:min(560px, calc(100% - 28px));
      background: rgba(20,18,34,.78);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 22px;
      box-shadow: var(--shadow);
      padding: 18px 18px 16px;
      color: rgba(255,255,255,.92);
    }
    .card h2{margin:0 0 8px;font-size:20px;font-weight:1200;}
    .card p{margin:0 0 12px;font-size:13px;line-height:1.35;opacity:.9;}

    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;}
    .chips{display:flex;gap:8px;flex-wrap:wrap;}

    .chipBtn{
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 999px;
      padding: 8px 12px;
      font-weight:1100;
      font-size:12px;
      color: rgba(255,255,255,.92);
      cursor:pointer;
      user-select:none;
    }
    .chipBtn.active{
      background: rgba(120,90,255,.32);
      border-color: rgba(120,90,255,.45);
    }

    .btn{
      background: rgba(255,255,255,.12);
      border: 1px solid rgba(255,255,255,.20);
      border-radius: 14px;
      padding: 10px 14px;
      font-weight:1200;
      color: rgba(255,255,255,.95);
      cursor:pointer;
      user-select:none;
      white-space:nowrap;
    }
    .btn.primary{
      background: rgba(120,90,255,.40);
      border-color: rgba(120,90,255,.55);
    }

    .hint{margin-top:10px;font-size:12px;opacity:.75;}

    #version{
      position:absolute; right:12px; bottom:40px;
      font-size:12px; opacity:.55; pointer-events:none; z-index:400;
      color: rgba(0,0,0,.35);
    }
  </style>
</head>

<body>
<div id="game">
  <div id="topbar">
    <div class="pill"><div class="label">–û—á–∫–∏</div><div class="value" id="score">0</div></div>
    <div class="pill" id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
  </div>

  <div id="questionWrap"><div id="questionBox">‚Äî</div></div>

  <div id="scene">
    <div class="orb" id="player"></div>
  </div>

  <div id="feedback"></div>

  <div id="progressWrap">
    <div id="progressBar">
      <div id="progressFill"></div>
      <div id="progressText">–í–æ–ø—Ä–æ—Å 1 –∏–∑ 1</div>
    </div>
  </div>

  <div id="startOverlay" class="overlay show">
    <div class="card">
      <h2>–ó–∞–¥–∞—á–∞ –∏–≥—Ä–æ–∫–∞</h2>
      <p>
        –í–æ–ø—Ä–æ—Å—ã –ø–æ—è–≤–ª—è—é—Ç—Å—è <b>—Ä–∞–Ω–¥–æ–º–Ω–æ</b> –∏–∑ —Å–ø–∏—Å–∫–∞.<br>
        –û—à–∏–±–∫–∞ = –º–∏–Ω—É—Å –∂–∏–∑–Ω—å, –Ω–æ –≤–æ–ø—Ä–æ—Å –æ—Å—Ç–∞—ë—Ç—Å—è –≤ –∏–≥—Ä–µ –∏ –º–æ–∂–µ—Ç –≤—ã–ø–∞—Å—Ç—å —Å–Ω–æ–≤–∞.
      </p>

      <div class="row">
        <div class="chips">
          <div class="chipBtn active" data-level="easy">–õ—ë–≥–∫–∏–π</div>
          <div class="chipBtn" data-level="medium">–°—Ä–µ–¥–Ω–∏–π</div>
          <div class="chipBtn" data-level="hard">–°–ª–æ–∂–Ω—ã–π</div>
        </div>
        <button class="btn primary" id="startBtn">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
      </div>

      <div class="hint">–ü—Ä–æ–ø—É—Å–∫–∞—Ç—å –æ—Ç–≤–µ—Ç—ã –º–æ–∂–Ω–æ ‚Äî —ç—Ç–æ –Ω–µ –æ—à–∏–±–∫–∞.</div>
    </div>
  </div>

  <div id="finalOverlay" class="overlay">
    <div class="card">
      <h2 id="finalTitle">‚Äî</h2>
      <p id="finalText">‚Äî</p>
      <div class="row" style="justify-content:flex-end;">
        <button class="btn primary" id="playAgainBtn">–ò–≥—Ä–∞—Ç—å –µ—â—ë</button>
        <button class="btn" id="menuBtn">–í –º–µ–Ω—é</button>
      </div>
    </div>
  </div>

  <div id="version">v18</div>
</div>

<script>
const CFG = {
  lives: 3,
  playerSpeed: 7,
  feedbackMs: 420,
  pointsPerCorrect: 10,
  soundVolume: 0.28,

  layout: { paddingTop: 130, paddingBottom: 86, laneMinDist: 108 },

  difficulty: {
    easy:   { speed: 2.4, spawnEveryMs: 1050, minXGap: 220, maxOnScreen: 4 },
    medium: { speed: 3.2, spawnEveryMs:  900, minXGap: 200, maxOnScreen: 5 },
    hard:   { speed: 4.1, spawnEveryMs:  760, minXGap: 180, maxOnScreen: 6 },
  },

  questions: [
    { q:"–°—Ç–æ–ª–∏—Ü–∞ –§—Ä–∞–Ω—Ü–∏–∏?", answers:[
      {label:"A", text:"–ü–∞—Ä–∏–∂",  correct:true},
      {label:"B", text:"–†–∏–º",    correct:false},
      {label:"C", text:"–ë–µ—Ä–ª–∏–Ω", correct:false},
    ]},
    { q:"2 + 2 = ?", answers:[
      {label:"A", text:"3", correct:false},
      {label:"B", text:"4", correct:true},
      {label:"C", text:"5", correct:false},
    ]},
    { q:"–ì–¥–µ –±–æ–ª—å—à–µ: 7 –∏–ª–∏ 9?", answers:[
      {label:"A", text:"7", correct:false},
      {label:"B", text:"9", correct:true},
      {label:"C", text:"—Ä–∞–≤–Ω—ã", correct:false},
    ]},
  ],
};

const scene = document.getElementById("scene");
const player = document.getElementById("player");
const questionBox = document.getElementById("questionBox");
const scoreEl = document.getElementById("score");
const livesEl = document.getElementById("lives");
const feedback = document.getElementById("feedback");
const progressFill = document.getElementById("progressFill");
const progressText = document.getElementById("progressText");

const startOverlay = document.getElementById("startOverlay");
const startBtn = document.getElementById("startBtn");
const diffBtns = Array.from(document.querySelectorAll(".chipBtn"));

const finalOverlay = document.getElementById("finalOverlay");
const finalTitle = document.getElementById("finalTitle");
const finalText = document.getElementById("finalText");
const playAgainBtn = document.getElementById("playAgainBtn");
const menuBtn = document.getElementById("menuBtn");

let keys = {};
let raf = null;
let state = null;
let pendingTimer = null;

/* ===== SOUND ===== */
let audioCtx = null, unlocked = false;
function ensureAudio(){
  if(audioCtx) return;
  const Ctx = window.AudioContext || window.webkitAudioContext;
  if(!Ctx) return;
  audioCtx = new Ctx();
}
async function unlockAudio(){
  ensureAudio();
  if(!audioCtx) return;
  if(audioCtx.state === "suspended") { try{ await audioCtx.resume(); }catch(e){} }
  unlocked = true;
}
function tone(freq, dur=0.16, type="sine", vol=CFG.soundVolume){
  if(!unlocked || !audioCtx) return;
  const now = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.setValueAtTime(freq, now);
  g.gain.setValueAtTime(0.0001, now);
  g.gain.exponentialRampToValueAtTime(vol, now + 0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(now);
  o.stop(now + dur + 0.03);
}
function soundStart(){
  tone(523.25, 0.10, "sine");
  setTimeout(()=>tone(659.25, 0.10, "sine"), 110);
  setTimeout(()=>tone(783.99, 0.14, "sine"), 230);
}
function soundOk(){
  tone(660, 0.10, "sine");
  setTimeout(()=>tone(990, 0.12, "sine"), 90);
}
function soundBad(){
  tone(220, 0.14, "square");
  setTimeout(()=>tone(180, 0.16, "sawtooth"), 90);
}
function soundWin(){
  const seq = [523,659,784,988,784,988,1175];
  seq.forEach((f,i)=>setTimeout(()=>tone(f, 0.12, "sine"), i*120));
}
function soundLose(){
  const seq = [392,330,294,262];
  seq.forEach((f,i)=>setTimeout(()=>tone(f, 0.18, "triangle"), i*160));
}
/* ================= */

function preset(level){ return CFG.difficulty[level] || CFG.difficulty.easy; }

function clearPending(){
  if(pendingTimer !== null){
    clearTimeout(pendingTimer);
    pendingTimer = null;
  }
}
function showOverlay(el, on){
  if(on) el.classList.add("show");
  else el.classList.remove("show");
}

function initState(){
  state = {
    phase: "menu",
    locked: true,

    score: 0,
    lives: CFG.lives,

    // ‚úÖ –ø—É–ª –Ω–µ—Ä–µ—à—ë–Ω–Ω—ã—Ö –≤–æ–ø—Ä–æ—Å–æ–≤
    remaining: [],

    // —Ç–µ–∫—É—â–∏–π –≤–æ–ø—Ä–æ—Å (–∏–Ω–¥–µ–∫—Å)
    currentIdx: null,

    active: [],
    lastSpawnAt: performance.now(),
    lastLaneY: null,

    difficulty: "easy",
    speed: preset("easy").speed,
    spawnEveryMs: preset("easy").spawnEveryMs,
    minXGap: preset("easy").minXGap,
    maxOnScreen: preset("easy").maxOnScreen,
  };
  state.remaining = CFG.questions.map((_, i)=>i);
}

function applyDifficulty(level){
  const p = preset(level);
  state.difficulty = level;
  state.speed = p.speed;
  state.spawnEveryMs = p.spawnEveryMs;
  state.minXGap = p.minXGap;
  state.maxOnScreen = p.maxOnScreen;
  diffBtns.forEach(b=>b.classList.toggle("active", b.dataset.level===level));
}

function hearts(n){ return "‚ù§Ô∏è".repeat(Math.max(0,n)) + (n<=0 ? "‚Äî" : ""); }

function pickRandomQuestion(){
  if(!state.remaining.length) return null;
  const r = Math.floor(Math.random() * state.remaining.length);
  return state.remaining[r];
}

function updateProgress(){
  const total = CFG.questions.length;
  const done = total - state.remaining.length;
  const current = Math.min(done + 1, total);
  const pct = total ? Math.round((done / total) * 100) : 0;
  progressFill.style.width = pct + "%";
  progressText.textContent = `–í–æ–ø—Ä–æ—Å ${current} –∏–∑ ${total}`;
}

function updateHUD(){
  scoreEl.textContent = String(state.score);
  livesEl.textContent = hearts(state.lives);

  const q = (state.currentIdx !== null) ? CFG.questions[state.currentIdx] : null;
  questionBox.textContent = q ? q.q : "";

  updateProgress();
}

function clearAnswers(){
  state.active.forEach(o=>o.el.remove());
  state.active = [];
  state.lastLaneY = null;
}

function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }

function buildLanes(){
  const minY = CFG.layout.paddingTop;
  const maxY = scene.clientHeight - CFG.layout.paddingBottom;
  const step = CFG.layout.laneMinDist;
  const lanes = [];
  for(let y=minY; y<=maxY; y+=step) lanes.push(y);
  return lanes.length ? lanes : [Math.round((minY+maxY)/2)];
}
function pickLaneY(){
  const lanes = buildLanes();
  let y = lanes[randInt(0, lanes.length-1)];
  if(state.lastLaneY !== null && lanes.length > 1){
    let tries=0;
    while(y === state.lastLaneY && tries<10){
      y = lanes[randInt(0, lanes.length-1)];
      tries++;
    }
  }
  state.lastLaneY = y;
  return y;
}

function createOrb(answer){
  const el = document.createElement("div");
  el.className = "orb answer";
  el.dataset.correct = answer.correct ? "1":"0";

  const lab = document.createElement("div");
  lab.className = "lab";
  lab.textContent = answer.label;

  const txt = document.createElement("div");
  txt.className = "txt";
  txt.textContent = answer.text;

  el.appendChild(lab);
  el.appendChild(txt);
  return el;
}

function rightEdgeX(){ return scene.clientWidth + 50; }
function newestX(){
  let maxX = -Infinity;
  for(const o of state.active) maxX = Math.max(maxX, o.el.offsetLeft);
  return maxX;
}

function maybeSpawn(now){
  if(state.phase !== "playing" || state.locked) return;
  if(state.active.length >= state.maxOnScreen) return;

  if(now - state.lastSpawnAt < state.spawnEveryMs) return;

  const spawnX = rightEdgeX();
  const nx = newestX();
  if(nx !== -Infinity && nx > (spawnX - state.minXGap)) return;

  const q = (state.currentIdx !== null) ? CFG.questions[state.currentIdx] : null;
  if(!q) return;

  const pick = q.answers[randInt(0, q.answers.length-1)];
  const el = createOrb(pick);
  el.style.left = spawnX + "px";
  el.style.top = pickLaneY() + "px";
  el.style.transform = "translate(-50%,-50%)";

  scene.appendChild(el);
  state.active.push({ el, data: pick, hit:false });

  state.lastSpawnAt = now;
}

function showFeedback(text, ok){
  feedback.textContent = text;
  feedback.style.color = ok ? "var(--good)" : "var(--bad)";
  feedback.classList.add("show");
  setTimeout(()=>feedback.classList.remove("show"), Math.max(120, CFG.feedbackMs - 80));
}

function showPointsPop(x,y,points){
  const pop = document.createElement("div");
  pop.className = "pop";
  pop.textContent = `+${points}`;
  pop.style.left = x + "px";
  pop.style.top = y + "px";
  scene.appendChild(pop);
  setTimeout(()=>pop.remove(), 900);
}

function endGame(win){
  clearPending();
  state.phase = "ended";
  state.locked = true;
  clearAnswers();
  updateHUD();

  if(win) soundWin(); else soundLose();

  finalTitle.textContent = win ? "üéâ –ú–æ–ª–æ–¥–µ—Ü!" : "üò¢ –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë";
  finalText.textContent = win
    ? `–¢—ã –æ—Ç–≤–µ—Ç–∏–ª(–∞) –Ω–∞ –≤—Å–µ –≤–æ–ø—Ä–æ—Å—ã! –û—á–∫–∏: ${state.score}.`
    : `–ñ–∏–∑–Ω–∏ –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å. –û—á–∫–∏: ${state.score}.`;

  showOverlay(finalOverlay, true);
}

function chooseNextQuestionRandom(){
  // ‚úÖ –≤—ã–±–æ—Ä –Ω–æ–≤–æ–≥–æ –≤–æ–ø—Ä–æ—Å–∞ —Ä–∞–Ω–¥–æ–º–Ω–æ –∏–∑ remaining
  state.currentIdx = pickRandomQuestion();
  if(state.currentIdx === null){
    endGame(true);
    return;
  }
  updateHUD();
  state.locked = false;
  clearAnswers();
  state.lastSpawnAt = performance.now();
}

function handleHit(correct, hitX, hitY){
  if(state.locked || state.phase !== "playing") return;

  state.locked = true;
  clearAnswers();
  clearPending();

  if(correct){
    state.score += CFG.pointsPerCorrect;
    showPointsPop(hitX, hitY, CFG.pointsPerCorrect);
    showFeedback("–í–µ—Ä–Ω–æ", true);
    soundOk();

    // ‚úÖ —É–¥–∞–ª—è–µ–º —Ç–µ–∫—É—â–∏–π –∏–∑ remaining
    const idx = state.currentIdx;
    state.remaining = state.remaining.filter(x => x !== idx);

    pendingTimer = setTimeout(()=> {
      pendingTimer = null;
      if(state.remaining.length === 0) endGame(true);
      else chooseNextQuestionRandom();
    }, CFG.feedbackMs);

  } else {
    state.lives--;
    showFeedback("–ù–µ–≤–µ—Ä–Ω–æ", false);
    soundBad();

    pendingTimer = setTimeout(()=> {
      pendingTimer = null;
      if(state.lives <= 0) endGame(false);
      else chooseNextQuestionRandom(); // ‚úÖ –¥–∞–ª—å—à–µ —Ä–∞–Ω–¥–æ–º–Ω–æ, –≤–æ–ø—Ä–æ—Å –æ—Å—Ç–∞—ë—Ç—Å—è –≤ remaining
    }, CFG.feedbackMs);
  }

  updateHUD();
}

function checkCollision(obj){
  if(obj.hit || state.locked || state.phase !== "playing") return;
  const a = obj.el.getBoundingClientRect();
  const p = player.getBoundingClientRect();
  const overlap = !(a.right<p.left || a.left>p.right || a.bottom<p.top || a.top>p.bottom);
  if(overlap){
    obj.hit = true;
    const sr = scene.getBoundingClientRect();
    const hitX = (a.left+a.right)/2 - sr.left;
    const hitY = (a.top+a.bottom)/2 - sr.top;
    obj.el.remove();
    handleHit(obj.data.correct===true, hitX, hitY);
  }
}

function resetGameForPlay(){
  clearPending();
  clearAnswers();

  state.score = 0;
  state.lives = CFG.lives;
  state.remaining = CFG.questions.map((_, i)=>i);

  state.phase = "playing";
  state.locked = false;

  state.currentIdx = pickRandomQuestion();
  state.lastSpawnAt = performance.now();
  player.style.top = "50%";
  updateHUD();
}

async function startGame(){
  await unlockAudio();
  soundStart();
  showOverlay(startOverlay, false);
  showOverlay(finalOverlay, false);
  resetGameForPlay();
}

async function playAgain(){
  await unlockAudio();
  soundStart();
  showOverlay(finalOverlay, false);
  showOverlay(startOverlay, false);
  resetGameForPlay();
}

function backToMenu(){
  clearPending();
  clearAnswers();
  state.phase = "menu";
  state.locked = true;
  state.currentIdx = null;
  showOverlay(finalOverlay, false);
  showOverlay(startOverlay, true);
  updateHUD();
}

function loop(now){
  if(state.phase === "playing"){
    let y = player.offsetTop;
    if(keys.ArrowUp) y -= CFG.playerSpeed;
    if(keys.ArrowDown) y += CFG.playerSpeed;
    y = Math.max(0, Math.min(scene.clientHeight - player.clientHeight, y));
    player.style.top = y + "px";

    maybeSpawn(now);

    if(!state.locked){
      const leftLimit = -160;
      const next = [];
      for(const obj of state.active){
        obj.el.style.left = (obj.el.offsetLeft - state.speed) + "px";
        checkCollision(obj);
        if(obj.el.isConnected){
          if(obj.el.offsetLeft >= leftLimit) next.push(obj);
          else obj.el.remove();
        }
      }
      state.active = next;
    }
  }
  raf = requestAnimationFrame(loop);
}

/* UI */
diffBtns.forEach(btn=>{
  btn.addEventListener("click", async ()=>{
    await unlockAudio();
    applyDifficulty(btn.dataset.level);
  });
});
startBtn.addEventListener("click", startGame);
playAgainBtn.addEventListener("click", playAgain);
menuBtn.addEventListener("click", backToMenu);

window.addEventListener("keydown", async (e)=>{
  keys[e.key]=true;
  await unlockAudio();
});
window.addEventListener("keyup",(e)=>keys[e.key]=false);
window.addEventListener("pointerdown", async ()=>{ await unlockAudio(); }, {passive:true });

/* init */
initState();
applyDifficulty("easy");
updateHUD();
player.style.top = "50%";
showOverlay(startOverlay, true);
showOverlay(finalOverlay, false);
loop(performance.now());
</script>
</body>
</html>
