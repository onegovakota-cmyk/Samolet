<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Catch the Answer v2</title>

<style>
  :root{
    --bg: transparent;
    --text: rgba(255,255,255,.92);
    --muted: rgba(255,255,255,.72);

    --panel-bg: rgba(10,10,20,.55);
    --panel-brd: rgba(255,255,255,.14);
    --shadow: 0 14px 50px rgba(0,0,0,.35);

    --accent: rgba(120,90,255,.95);

    /* –≤—Å–µ –æ—Ç–≤–µ—Ç—ã –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ, –æ–¥–Ω–æ–≥–æ —Ü–≤–µ—Ç–∞ */
    --answer-bg: rgba(255,255,255,.16);
    --answer-brd: rgba(255,255,255,.18);
    --answer-text: rgba(255,255,255,.92);

    --good: #4cff9e;
    --bad:  #ff6b6b;

    /* –∏–≥—Ä–æ–∫ –∏ –æ—Ç–≤–µ—Ç—ã –æ–¥–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ */
    --size: 58px;
  }

  html,body{
    margin:0;height:100%;
    background: var(--bg) !important;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    color:var(--text);
    overflow:hidden;
  }
  #game{position:relative;width:100%;height:100%;}

  /* HUD: —Å–ª–µ–≤–∞ –æ—á–∫–∏, —Å–ø—Ä–∞–≤–∞ –∂–∏–∑–Ω–∏ */
  #hud{
    position:absolute; top:12px; left:12px; right:12px;
    display:flex; align-items:flex-start; justify-content:space-between;
    gap:12px; z-index:20; pointer-events:none;
  }

  .pill{
    background: var(--panel-bg);
    border: 1px solid var(--panel-brd);
    border-radius: 999px;
    padding: 10px 12px;
    box-shadow: var(--shadow);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    display:flex; gap:10px; align-items:center;
    white-space:nowrap;
  }
  .pill .label{font-size:12px;color:var(--muted);font-weight:900;letter-spacing:.2px}
  .pill .value{font-size:16px;font-weight:1100}

  /* –í–û–ü–†–û–°: —Å—Ç—Ä–æ–≥–æ –ø–æ —Ü–µ–Ω—Ç—Ä—É —Å–≤–µ—Ä—Ö—É –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π —Ä–∞–º–æ—á–∫–µ */
  #questionWrap{
    position:absolute; top:12px; left:50%;
    transform:translateX(-50%);
    z-index:21; pointer-events:none;
    max-width:min(860px, calc(100% - 24px));
  }
  #questionBox{
    background: var(--panel-bg);
    border: 1px solid var(--panel-brd);
    border-radius: 999px;
    padding: 12px 16px;
    box-shadow: var(--shadow);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
    text-align:center;
    font-weight:1000;
    font-size:14px;
    letter-spacing:.2px;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
  }

  /* –°—Ü–µ–Ω–∞ */
  #scene{position:absolute; inset:0; overflow:hidden;}

  /* –ò–≥—Ä–æ–∫ –∏ –æ—Ç–≤–µ—Ç—ã */
  .orb{
    position:absolute;
    width: var(--size);
    height: var(--size);
    border-radius: 50%;
    display:flex; align-items:center; justify-content:center;
    user-select:none;
  }

  #player{
    left:72px;
    top:50%;
    transform:translate(-50%,-50%);
    background: rgba(120,90,255,.22);
    border: 1px solid rgba(120,90,255,.35);
    box-shadow: 0 12px 35px rgba(0,0,0,.25), 0 0 22px rgba(120,90,255,.25);
  }
  #player:before{
    content:"";
    width: 18px; height: 18px;
    border-radius: 999px;
    background: rgba(255,255,255,.85);
    box-shadow: 0 0 12px rgba(255,255,255,.25);
  }

  .answer{
    background: var(--answer-bg);
    border: 1px solid var(--answer-brd);
    box-shadow: 0 14px 45px rgba(0,0,0,.28);
    color: var(--answer-text);
    font-weight:1100;
    font-size:18px;
    letter-spacing:.5px;
  }

  /* +–æ—á–∫–∏ */
  .pop{
    position:absolute;
    font-weight:1100;
    font-size:18px;
    pointer-events:none;
    transform:translate(-50%,-50%);
    text-shadow: 0 14px 30px rgba(0,0,0,.5);
    animation: popUp .78s ease-out forwards;
    z-index:30;
  }
  @keyframes popUp{
    0%   { opacity:0; transform:translate(-50%,-50%) scale(.9); }
    15%  { opacity:1; transform:translate(-50%,-62%) scale(1.05); }
    100% { opacity:0; transform:translate(-50%,-105%) scale(1.0); }
  }

  /* –§–∏–¥–±–µ–∫ */
  #feedback{
    position:absolute; inset:0;
    display:flex; align-items:center; justify-content:center;
    font-size:30px; font-weight:1100;
    pointer-events:none;
    opacity:0; transition:.18s;
    z-index:25;
  }
  #feedback.show{ opacity:1; }

  /* –§–∏–Ω–∞–ª */
  #final{
    position:absolute; inset:0;
    background: rgba(0,0,0,.78);
    display:none;
    align-items:center; justify-content:center;
    flex-direction:column;
    gap:14px;
    z-index:40;
    text-align:center;
    padding:20px;
  }
  #final.show{ display:flex; }
  #final h1{ margin:0; font-size:30px; }
  #final .small{ opacity:.8; max-width:560px; line-height:1.4; font-size:13px; }
  #final button{
    pointer-events:auto;
    padding:10px 16px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.18);
    background: rgba(255,255,255,.10);
    color: rgba(255,255,255,.92);
    font-weight:1000;
    cursor:pointer;
  }

  /* –Ø–≤–Ω—ã–π –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –≤–µ—Ä—Å–∏–∏ (—á—Ç–æ–±—ã —É–≤–∏–¥–µ—Ç—å, —á—Ç–æ –∫–æ–¥ –æ–±–Ω–æ–≤–∏–ª—Å—è) */
  #version{
    position:absolute; bottom:10px; right:12px;
    font-size:12px; opacity:.55;
    pointer-events:none;
  }
</style>
</head>

<body>
<div id="game">

  <div id="hud">
    <div class="pill">
      <div class="label">–û—á–∫–∏</div>
      <div class="value" id="score">0</div>
    </div>

    <div class="pill" id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
  </div>

  <div id="questionWrap">
    <div id="questionBox">‚Äî</div>
  </div>

  <div id="scene">
    <div class="orb" id="player"></div>
  </div>

  <div id="feedback"></div>

  <div id="final">
    <h1 id="finalTitle">‚Äî</h1>
    <div class="small" id="finalText"></div>
    <button onclick="restart()">–ò–≥—Ä–∞—Ç—å –µ—â—ë</button>
  </div>

  <div id="version">v2</div>
</div>

<script>
const GAME_CONFIG = {
  lives: 3,
  speed: 3.0,
  playerSpeed: 7,
  feedbackMs: 420,

  scoring: {
    pointsPerCorrect: 10,
    popColor: "#4cff9e",
    popText: (pts)=>`+${pts}`,
  },

  layout: {
    paddingTop: 92,
    paddingBottom: 34,
    minDistY: 88,
    startX: 120,
    xSpreadMin: 110,
    xSpreadMax: 190,
  },

  questions: [
    { q: "–°—Ç–æ–ª–∏—Ü–∞ –§—Ä–∞–Ω—Ü–∏–∏?", answers: [
      { label:"A", correct:false }, { label:"B", correct:true }, { label:"C", correct:false }
    ]},
    { q: "2 + 2 = ?", answers: [
      { label:"A", correct:false }, { label:"B", correct:true }, { label:"C", correct:false }
    ]},
    { q: "–ì–¥–µ –±–æ–ª—å—à–µ: 7 –∏–ª–∏ 9?", answers: [
      { label:"A", correct:false }, { label:"B", correct:true }, { label:"C", correct:false }
    ]},
  ],
};

const scene = document.getElementById("scene");
const player = document.getElementById("player");
const questionBox = document.getElementById("questionBox");
const scoreEl = document.getElementById("score");
const livesEl = document.getElementById("lives");
const feedback = document.getElementById("feedback");
const final = document.getElementById("final");
const finalTitle = document.getElementById("finalTitle");
const finalText = document.getElementById("finalText");

let keys = {};
let raf = null;
let state = null;

function initState(){
  state = { qIndex:0, lives:GAME_CONFIG.lives, score:0, active:[], locked:false };
}

function hearts(n){ return "‚ù§Ô∏è".repeat(Math.max(0,n)) + (n<=0 ? "‚Äî" : ""); }

function updateHUD(){
  scoreEl.textContent = String(state.score);
  livesEl.textContent = hearts(state.lives);
  questionBox.textContent = state.qIndex < GAME_CONFIG.questions.length ? GAME_CONFIG.questions[state.qIndex].q : "";
}

function clearAnswers(){
  state.active.forEach(o=>o.el.remove());
  state.active = [];
}

function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }

function spawnAnswersForQuestion(){
  clearAnswers();
  const q = GAME_CONFIG.questions[state.qIndex];
  const L = GAME_CONFIG.layout;

  const usedY = [];
  const startX = scene.clientWidth + L.startX;

  function pickY(){
    const minY = L.paddingTop;
    const maxY = scene.clientHeight - L.paddingBottom;
    for(let attempt=0; attempt<40; attempt++){
      const y = randInt(minY, maxY);
      if(usedY.every(prev => Math.abs(prev-y) >= L.minDistY)){
        usedY.push(y); return y;
      }
    }
    const fallback = randInt(minY, maxY);
    usedY.push(fallback);
    return fallback;
  }

  const shuffled = [...q.answers].sort(()=>Math.random()-0.5);

  shuffled.forEach((a,i)=>{
    const el = document.createElement("div");
    el.className = "orb answer";
    el.textContent = a.label;              // –æ—Ç–≤–µ—Ç—ã –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ (—Ç–æ–ª—å–∫–æ –±—É–∫–≤–∞)
    el.dataset.correct = a.correct ? "1":"0";

    const xOffset = i * randInt(L.xSpreadMin, L.xSpreadMax);
    el.style.left = (startX + xOffset) + "px";
    el.style.top = pickY() + "px";
    el.style.transform = "translate(-50%,-50%)";

    scene.appendChild(el);
    state.active.push({ el, data:a, hit:false });
  });
}

function showFeedback(text, ok){
  feedback.textContent = text;
  feedback.style.color = ok ? "var(--good)" : "var(--bad)";
  feedback.classList.add("show");
  setTimeout(()=>feedback.classList.remove("show"), Math.max(120, GAME_CONFIG.feedbackMs - 80));
}

function showPointsPop(x,y,points){
  const pop = document.createElement("div");
  pop.className = "pop";
  pop.textContent = GAME_CONFIG.scoring.popText(points);
  pop.style.color = GAME_CONFIG.scoring.popColor;
  pop.style.left = x + "px";
  pop.style.top = y + "px";
  scene.appendChild(pop);
  setTimeout(()=>pop.remove(), 900);
}

function endGame(win){
  state.locked = true;
  clearAnswers();
  updateHUD();

  final.classList.add("show");
  finalTitle.textContent = win ? "üéâ –û—Ç–ª–∏—á–Ω–æ!" : "üíÄ –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞";
  const total = GAME_CONFIG.questions.length;
  const answered = Math.min(state.qIndex, total);
  finalText.textContent = `–ü—Ä–æ–π–¥–µ–Ω–æ ${answered}/${total}. –û—á–∫–∏: ${state.score}.`;

  if(raf) cancelAnimationFrame(raf);
  raf = null;
}

function goNextQuestion(){
  state.qIndex++;
  if(state.lives <= 0){ endGame(false); return; }
  if(state.qIndex >= GAME_CONFIG.questions.length){ endGame(true); return; }
  state.locked = false;
  updateHUD();
  spawnAnswersForQuestion();
}

function handleAnswer(correct, hitX, hitY){
  if(state.locked) return;
  state.locked = true;
  clearAnswers();

  if(correct){
    const pts = GAME_CONFIG.scoring.pointsPerCorrect;
    state.score += pts;
    updateHUD();
    showPointsPop(hitX, hitY, pts);
    showFeedback("–í–µ—Ä–Ω–æ", true);
  } else {
    state.lives--;
    updateHUD();
    showFeedback("–ù–µ–≤–µ—Ä–Ω–æ", false);
    player.animate(
      [{transform:"translate(-50%,-50%)"},
       {transform:"translate(-50%,-50%) translateX(-4px)"},
       {transform:"translate(-50%,-50%) translateX(4px)"},
       {transform:"translate(-50%,-50%)"}],
      {duration:220}
    );
  }

  setTimeout(goNextQuestion, GAME_CONFIG.feedbackMs);
}

function checkCollision(obj){
  if(obj.hit || state.locked) return;

  const a = obj.el.getBoundingClientRect();
  const p = player.getBoundingClientRect();
  const overlap = !(a.right < p.left || a.left > p.right || a.bottom < p.top || a.top > p.bottom);

  if(overlap){
    obj.hit = true;
    const sceneRect = scene.getBoundingClientRect();
    const hitX = (a.left + a.right)/2 - sceneRect.left;
    const hitY = (a.top + a.bottom)/2 - sceneRect.top;

    obj.el.remove();
    handleAnswer(obj.data.correct === true, hitX, hitY);
  }
}

function loop(){
  if(!state) return;

  let y = player.offsetTop;
  if(keys.ArrowUp) y -= GAME_CONFIG.playerSpeed;
  if(keys.ArrowDown) y += GAME_CONFIG.playerSpeed;
  y = Math.max(0, Math.min(scene.clientHeight - player.clientHeight, y));
  player.style.top = y + "px";

  if(!state.locked){
    state.active.forEach(obj=>{
      obj.el.style.left = (obj.el.offsetLeft - GAME_CONFIG.speed) + "px";
      checkCollision(obj);
    });
  }

  raf = requestAnimationFrame(loop);
}

function restart(){
  final.classList.remove("show");
  if(raf) cancelAnimationFrame(raf);
  raf = null;

  initState();
  updateHUD();
  player.style.top = "50%";
  spawnAnswersForQuestion();
  loop();
}

window.addEventListener("keydown",(e)=>keys[e.key]=true);
window.addEventListener("keyup",(e)=>keys[e.key]=false);

initState();
updateHUD();
player.style.top = "50%";
spawnAnswersForQuestion();
loop();
</script>
</body>
</html>
