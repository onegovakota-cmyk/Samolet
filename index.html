<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Игра + Редактор (одним файлом)</title>
  <link rel="icon" href="data:,">
  <style>
    :root{
      --ui-card: rgba(18,16,32,.78);
      --ui-border: rgba(255,255,255,.14);
      --ui-text: rgba(255,255,255,.92);
      --ui-sub: rgba(255,255,255,.68);
      --shadow: 0 18px 65px rgba(0,0,0,.45);
      --accent: rgba(120,90,255,.55);
      --accent-border: rgba(120,90,255,.65);
    }
    html,body{margin:0;height:100%;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:transparent;}
    body{overflow:hidden;}

    #editorApp{
      height:100%;
      display:flex;
      gap:12px;
      padding:12px;
      box-sizing:border-box;
      background: radial-gradient(1200px 600px at 20% 10%, rgba(120,90,255,.18), transparent 60%),
                  radial-gradient(900px 500px at 85% 20%, rgba(76,255,158,.08), transparent 55%),
                  rgba(10,10,16,.98);
      color:var(--ui-text);
    }
    .panel{
      background: var(--ui-card);
      border:1px solid var(--ui-border);
      border-radius:16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #left{
      width:min(660px, 56vw);
      min-width:390px;
      display:flex;flex-direction:column;overflow:hidden;
    }
    #right{flex:1;display:flex;flex-direction:column;overflow:hidden;}
    .head{
      padding:14px 14px 10px;
      border-bottom:1px solid rgba(255,255,255,.10);
      display:flex;align-items:flex-start;justify-content:space-between;gap:10px;
    }
    .head h1{margin:0;font-size:16px;font-weight:900;letter-spacing:.2px;}
    .head .sub{margin-top:4px;font-size:12px;color:var(--ui-sub);line-height:1.35;}
    .content{padding:12px 14px 14px;overflow:auto;}
    .section{
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:12px;
      margin:10px 0;
      background: rgba(255,255,255,.04);
    }
    .section h3{margin:0 0 10px;font-size:13px;font-weight:900;color:rgba(255,255,255,.90);}
    .grid{display:grid;grid-template-columns: 1fr 1fr;gap:10px;}
    label{display:block;font-size:12px;color:var(--ui-sub);margin-bottom:6px;}
    input[type="text"], input[type="number"], select, textarea{
      width:100%;box-sizing:border-box;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.95);
      border-radius:12px;padding:10px 10px;outline:none;font-size:13px;
    }
    textarea{min-height:110px; resize:vertical; line-height:1.35;}
    input[type="color"]{
      width:100%;height:42px;border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      padding:6px;box-sizing:border-box;
    }
    input[type="range"]{width:100%;}
    .rangeRow{display:grid;grid-template-columns: 1fr 86px;gap:10px;align-items:center;}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;}
    .btn{
      appearance:none;border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.10);
      color: rgba(255,255,255,.95);
      padding:10px 12px;border-radius:12px;
      font-weight:800;font-size:13px;cursor:pointer;user-select:none;white-space:nowrap;
    }
    .btn.primary{background: var(--accent);border-color: var(--accent-border);}
    .btn.danger{background: rgba(255,107,107,.25);border-color: rgba(255,107,107,.45);}
    .hint{font-size:12px;color: var(--ui-sub);line-height:1.35;margin-top:6px;}
    .hr{height:1px;background:rgba(255,255,255,.10);margin:10px 0;}
    .badge{
      font-size:11px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(255,255,255,.85);
      white-space:nowrap;
    }

    .qitem{border:1px solid rgba(255,255,255,.10);border-radius:14px;padding:10px;background: rgba(0,0,0,.12);margin-bottom:10px;}
    .qtop{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-bottom:8px;}
    .qtop strong{font-size:12px;}
    .answers{display:flex;flex-direction:column;gap:8px;}
    .ansRow{display:grid;grid-template-columns: 52px 1fr 84px;gap:8px;align-items:center;}
    .chk{display:flex;gap:8px;align-items:center;font-size:12px;color: rgba(255,255,255,.85);}
    .chk input{width:18px;height:18px;}
    .miniBtn{padding:8px 10px;border-radius:10px;font-size:12px;}

    #previewWrap{flex:1;display:flex;flex-direction:column;overflow:hidden;}
    #previewFrame{width:100%;flex:1;border:0;background:transparent;}

    #codeBox{
      width:100%;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.20);
      color: rgba(255,255,255,.95);
      padding:12px;
      box-sizing:border-box;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12px;
      line-height:1.35;
      outline:none;
      resize:vertical;
    }

    .checkGrid{display:grid;grid-template-columns: 1fr 1fr;gap:8px;}
    .checkItem{
      display:flex;align-items:center;gap:10px;
      padding:10px 10px;border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.12);
      font-size:13px;color:rgba(255,255,255,.92);
    }
    .checkItem input{width:18px;height:18px;}

    #gameRoot{position:relative;width:100%;height:100%;overflow:hidden;background:transparent;}
  </style>
</head>

<body>
<div id="editorApp" style="display:none;">
  <div id="left" class="panel">
    <div class="head">
      <div>
        <h1>Редактор игры (Genially)</h1>
        <div class="sub">v32: предпросмотр всегда открывает текущий файл • iframe генерируется по baseUrl • управление сенсором • наклон и парение игрока • ответы без подложки (картинка) • ползунки и предпросмотр ответа.</div>
      </div>
      <div class="badge">v32 • one-file</div>
    </div>

    <div class="content">
      <div class="section">
        <h3>Ссылка проекта (только для iframe)</h3>
        <label>Base URL (GitHub Pages / путь к .html)</label>
        <input id="baseUrl" type="text" placeholder="https://username.github.io/repo/файл.html" />
        <div class="hint">Предпросмотр справа всегда показывает этот текущий файл. Base URL нужен только для iframe в Genially.</div>
      </div>

      <div class="section">
        <h3>Цвета</h3>
        <div class="grid">
          <div>
            <label>Вопрос: цвет текста</label>
            <input id="questionColor" type="color" value="#ffffff" />
          </div>
          <div>
            <label>Вопрос: цвет фона</label>
            <input id="questionBgColor" type="color" value="#0a0a14" />
          </div>
          <div>
            <label>Вопрос: цвет рамки</label>
            <input id="questionBorderColor" type="color" value="#ffffff" />
          </div>
          <div>
            <label>Цвет иконок (старт/финиш)</label>
            <input id="iconColor" type="color" value="#7a5aff" />
          </div>
          <div>
            <label>Кнопки: цвет фона</label>
            <input id="btnColor" type="color" value="#7a5aff" />
          </div>
          <div>
            <label>Кнопки: цвет текста</label>
            <input id="btnTextColor" type="color" value="#ffffff" />
          </div>
        </div>
      </div>

      <div class="section">
        <h3>Текст и HUD</h3>
        <div class="grid">
          <div>
            <label>Шрифт</label>
            <select id="fontFamily">
              <option value="system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif">Системный</option>
              <option value="'Arial', sans-serif">Arial</option>
              <option value="'Trebuchet MS', sans-serif">Trebuchet</option>
              <option value="'Comic Sans MS', 'Comic Sans', cursive">Comic Sans</option>
              <option value="'Verdana', sans-serif">Verdana</option>
            </select>
          </div>
          <div>
            <label>Насыщенность</label>
            <select id="fontWeight">
              <option value="900">Очень жирный</option>
              <option value="700">Жирный</option>
              <option value="600">Полужирный</option>
              <option value="500">Обычный</option>
            </select>
          </div>

          <div>
            <label>Размер вопроса (px)</label>
            <input id="questionSize" type="number" min="12" max="70" value="24" />
          </div>

          <div>
            <label>Размер очков (px)</label>
            <input id="scoreSize" type="number" min="12" max="70" value="24" />
          </div>
          <div>
            <label>Размер жизней (px)</label>
            <input id="livesSize" type="number" min="12" max="70" value="24" />
          </div>

          <div>
            <label>HUD: цвет текста</label>
            <input id="hudTextColor" type="color" value="#ffffff" />
          </div>
          <div>
            <label>HUD: цвет подложки</label>
            <input id="hudPanelColor" type="color" value="#0f0f19" />
          </div>
        </div>
      </div>

      <div class="section">
        <h3>Фразы обратной связи</h3>
        <div class="grid">
          <div>
            <label>За правильный</label>
            <input id="feedbackCorrect" type="text" value="Верно!" />
          </div>
          <div>
            <label>За неправильный</label>
            <input id="feedbackWrong" type="text" value="Неверно!" />
          </div>
        </div>
      </div>

      <div class="section">
        <h3>Эффекты текста</h3>
        <div class="checkGrid" style="margin-bottom:10px;">
          <div class="checkItem"><input id="fxShadow" type="checkbox" /> <span>Тень</span></div>
          <div class="checkItem"><input id="fxNeon" type="checkbox" checked /> <span>Неоновая подсветка</span></div>
          <div class="checkItem"><input id="fxStroke" type="checkbox" checked /> <span>Обводка</span></div>
          <div class="checkItem"><input id="fxStrokeNeon" type="checkbox" /> <span>Неоновая обводка</span></div>
        </div>

        <label>Применять эффекты к</label>
        <div class="checkGrid" style="margin-bottom:10px;">
          <div class="checkItem"><input id="fxToQuestion" type="checkbox" checked /> <span>Вопрос</span></div>
          <div class="checkItem"><input id="fxToHud" type="checkbox" checked /> <span>HUD</span></div>
          <div class="checkItem"><input id="fxToAnswers" type="checkbox" checked /> <span>Ответы</span></div>
          <div class="checkItem"><input id="fxToPoints" type="checkbox" checked /> <span>“+очки”</span></div>
        </div>

        <div class="grid">
          <div>
            <label>Цвет эффекта</label>
            <input id="fxColor" type="color" value="#ffd84a" />
          </div>
          <div>
            <label>Сила эффекта (1–12)</label>
            <input id="fxStrength" type="number" min="1" max="12" value="7" />
          </div>
        </div>

        <div class="grid" style="margin-top:10px;">
          <div>
            <label>Толщина контура (px)</label>
            <input id="strokeWidth" type="number" min="0" max="3" step="0.1" value="0.6" />
          </div>
          <div>
            <label>Цвет контура</label>
            <input id="strokeColor" type="color" value="#000000" />
          </div>
        </div>
      </div>

      <div class="section">
        <h3>Прогресс-бар</h3>
        <div class="grid">
          <div>
            <label>Высота (px)</label>
            <input id="progressHeight" type="number" min="14" max="70" value="30" />
          </div>
          <div>
            <label>Цвет прогресса</label>
            <input id="progressColor" type="color" value="#7a5aff" />
          </div>
        </div>
      </div>

      <div class="section">
        <h3>Картинки</h3>
        <div class="grid">
          <div>
            <label>Игрок — URL</label>
            <input id="playerImgUrl" type="text" placeholder="https://..." />
            <div class="hint">или загрузить:</div>
            <input id="playerImgFile" type="file" accept="image/*" />
          </div>
          <div>
            <label>Картинка ответа (фон) — URL</label>
            <input id="answerCardImgUrl" type="text" placeholder="https://..." />
            <div class="hint">или загрузить:</div>
            <input id="answerCardImgFile" type="file" accept="image/*" />
            <div class="hint" id="answerImgStatus" style="margin-top:6px;">Статус: —</div>
          </div>
          <div>
            <label>Фон игры — URL</label>
            <input id="bgImgUrl" type="text" placeholder="https://..." />
            <div class="hint">или загрузить:</div>
            <input id="bgImgFile" type="file" accept="image/*" />
          </div>
          <div>
            <label>Прозрачный фон (для Genially)</label>
            <select id="transparentBg">
              <option value="1" selected>Да</option>
              <option value="0">Нет</option>
            </select>
          </div>
        </div>
      </div>

      <div class="section">
        <h3>Игрок: размер и тень</h3>
        <label>Размер игрока (px)</label>
        <div class="rangeRow">
          <input id="playerSizeR" type="range" min="56" max="180" step="1" value="86" />
          <input id="playerSize" type="number" min="56" max="180" step="1" value="86" />
        </div>
        <div class="checkGrid" style="margin-top:10px;">
          <div class="checkItem"><input id="playerShadow" type="checkbox" /> <span>Тень по контуру игрока</span></div>
        </div>
      </div>

      <div class="section">
        <h3>Ответы: ползунки</h3>

        <label>Размер ответа (px)</label>
        <div class="rangeRow">
          <input id="answerSizeR" type="range" min="56" max="220" step="1" value="86" />
          <input id="answerSize" type="number" min="56" max="220" step="1" value="86" />
        </div>

        <label style="margin-top:10px;">Масштаб контента</label>
        <div class="rangeRow">
          <input id="answerContentScaleR" type="range" min="0.6" max="1.6" step="0.05" value="1" />
          <input id="answerContentScale" type="number" min="0.6" max="1.6" step="0.05" value="1" />
        </div>

        <div class="hr"></div>

        <label>Положение текста X (%)</label>
        <div class="rangeRow">
          <input id="answerTextXR" type="range" min="0" max="100" step="1" value="50" />
          <input id="answerTextX" type="number" min="0" max="100" step="1" value="50" />
        </div>

        <label style="margin-top:10px;">Положение текста Y (%)</label>
        <div class="rangeRow">
          <input id="answerTextYR" type="range" min="0" max="100" step="1" value="64" />
          <input id="answerTextY" type="number" min="0" max="100" step="1" value="64" />
        </div>

        <div class="checkGrid" style="margin-top:10px;">
          <div class="checkItem"><input id="answerTextBgOn" type="checkbox" checked /> <span>Подложка у текста ответа</span></div>
        </div>

        <div class="hr"></div>

        <label>Картинка ответа: режим</label>
        <select id="answerCardFit">
          <option value="contain" selected>Вписать (contain)</option>
          <option value="cover">Заполнить (cover)</option>
        </select>

        <label style="margin-top:10px;">Картинка ответа: масштаб</label>
        <div class="rangeRow">
          <input id="answerCardScaleR" type="range" min="0.6" max="2" step="0.05" value="1" />
          <input id="answerCardScale" type="number" min="0.6" max="2" step="0.05" value="1" />
        </div>

        <label style="margin-top:10px;">Картинка ответа X (%)</label>
        <div class="rangeRow">
          <input id="answerCardPosXR" type="range" min="0" max="100" step="1" value="50" />
          <input id="answerCardPosX" type="number" min="0" max="100" step="1" value="50" />
        </div>

        <label style="margin-top:10px;">Картинка ответа Y (%)</label>
        <div class="rangeRow">
          <input id="answerCardPosYR" type="range" min="0" max="100" step="1" value="50" />
          <input id="answerCardPosY" type="number" min="0" max="100" step="1" value="50" />
        </div>

        <div class="hint">Буква у вариантов в игре убрана. Ответы рисуются только через твою картинку + текст.</div>
      </div>

      <div class="section">
        <h3>Предпросмотр карточки ответа</h3>
        <div class="hint">Один ответ: картинка + текст + ползунки (чтобы красиво оформить).</div>

        <div style="display:flex;gap:12px;align-items:flex-start;flex-wrap:wrap;margin-top:10px;">
          <div id="answerPreviewBox" style="
            width:240px;height:240px;
            border-radius:16px;
            border:1px solid rgba(255,255,255,.14);
            background: rgba(0,0,0,.18);
            display:flex;align-items:center;justify-content:center;
            position:relative;
            overflow:hidden;
          ">
            <div id="answerPreviewOrb" style="width:86px;height:86px;border-radius:999px;position:relative;">
              <div id="answerPreviewImg" style="
                position:absolute; inset:0;
                border-radius:999px;
                background: transparent;
                background-repeat:no-repeat;
                background-position:50% 50%;
                background-size:contain;
                transform:scale(1);
              "></div>

              <div id="answerPreviewLayer" style="
                position:absolute; inset:0;
                transform:scale(1);
                transform-origin:50% 50%;
                pointer-events:none;
              ">
                <div id="answerPreviewText" style="
                  position:absolute; left:50%; top:64%;
                  transform:translate(-50%,-50%);
                  font-weight:700;
                  font-size:13px;
                  color:#fff;
                  max-width: 220px;
                  text-align:center;
                  padding:4px 8px;
                  border-radius:10px;
                  background: rgba(0,0,0,.18);
                  border: 1px solid rgba(255,255,255,.10);
                  text-shadow:0 10px 22px rgba(0,0,0,.55);
                ">Текст варианта</div>
              </div>
            </div>
          </div>

          <div style="flex:1;min-width:220px;">
            <label>Текст для предпросмотра</label>
            <input id="answerPreviewTextInput" type="text" value="Текст варианта" />
            <div class="hint">Это только для предпросмотра (на вопросы не влияет).</div>

            <div class="hr"></div>
            <div class="hint">
              Для бесшовного фона используй бесшовную картинку (seamless/tile). Фон движется repeat-x.
            </div>
          </div>
        </div>
      </div>

      <div class="section">
        <h3>Правила игры</h3>
        <div class="grid">
          <div>
            <label>Жизни</label>
            <input id="livesCount" type="number" min="1" max="10" value="3" />
          </div>
          <div>
            <label>Очки за правильный</label>
            <input id="pointsPerCorrect" type="number" min="1" max="200" value="10" />
          </div>
          <div>
            <label>Откат вопросов (cooldown)</label>
            <input id="cooldownTurns" type="number" min="0" max="10" value="3" />
          </div>
          <div>
            <label>Скорость игрока</label>
            <input id="playerSpeed" type="number" min="3" max="18" value="7" />
          </div>
        </div>
      </div>

      <div class="section">
        <h3>Вопросы и варианты</h3>
        <div class="row">
          <button class="btn miniBtn" id="addQuestionBtn">+ Добавить вопрос</button>
          <button class="btn miniBtn danger" id="resetQuestionsBtn">Сбросить демо</button>
        </div>
        <div class="hint">Галочка “верный” должна быть ровно у одного варианта.</div>
        <div id="questionsList" style="margin-top:10px;"></div>
      </div>

      <div class="section">
        <h3>Предпросмотр и iframe</h3>
        <div class="row">
          <button class="btn" id="applyPreviewBtn">Применить к предпросмотру</button>
          <button class="btn primary" id="genIframeBtn">Создать iframe</button>
          <button class="btn" id="copyIframeBtn">Скопировать</button>
        </div>
        <div class="hint">Предпросмотр справа использует текущий файл. iframe — baseUrl (GitHub Pages).</div>
        <textarea id="codeBox" readonly placeholder="Тут появится iframe..."></textarea>
      </div>
    </div>
  </div>

  <div id="right" class="panel">
    <div class="head">
      <div>
        <h1>Предпросмотр игры</h1>
        <div class="sub">Справа — всегда текущий файл (без кеша).</div>
      </div>
      <div class="badge" id="cfgSizeBadge">cfg: —</div>
    </div>
    <div id="previewWrap">
      <iframe id="previewFrame" title="preview"></iframe>
    </div>
  </div>
</div>

<div id="gameRoot" style="display:none;"></div>

<script>
/* ===== helpers ===== */
function b64urlEncode(str){
  const b64 = btoa(unescape(encodeURIComponent(str)));
  return b64.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}
function b64urlDecode(b64url){
  let b64 = b64url.replace(/-/g,'+').replace(/_/g,'/');
  while(b64.length % 4) b64 += '=';
  return decodeURIComponent(escape(atob(b64)));
}
function deepClone(o){ return JSON.parse(JSON.stringify(o)); }
function cssUrl(u){ return String(u||"").replace(/'/g,"%27"); }
function escapeCss(s){ return String(s||"").replace(/</g,"").replace(/>/g,"").replace(/"/g,""); }
function clampNum(v,a,b,d){ const n=Number(v); if(!Number.isFinite(n)) return d; return Math.max(a, Math.min(b, n)); }
function clampInt(v,a,b,d){ const n=Number(v); if(!Number.isFinite(n)) return d; return Math.max(a, Math.min(b, Math.round(n))); }
function hexToRgba(hex, alpha){
  const h=String(hex||"").replace("#","");
  if(h.length!==6) return `rgba(255,255,255,${alpha})`;
  const r=parseInt(h.slice(0,2),16), g=parseInt(h.slice(2,4),16), b=parseInt(h.slice(4,6),16);
  return `rgba(${r},${g},${b},${alpha})`;
}
function pairSync(rangeEl, numberEl, v){
  rangeEl.value = String(v);
  numberEl.value = String(v);
}
function pairBind(rangeEl, numberEl, onChange){
  rangeEl.addEventListener("input", ()=>{ numberEl.value = rangeEl.value; onChange(); });
  numberEl.addEventListener("input", ()=>{ rangeEl.value = numberEl.value; onChange(); });
  rangeEl.addEventListener("change", ()=>{ numberEl.value = rangeEl.value; onChange(); });
  numberEl.addEventListener("change", ()=>{ rangeEl.value = numberEl.value; onChange(); });
}

/* ===== default cfg ===== */
const DEFAULT_CFG = {
  fontFamily: "system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif",
  fontWeight: 900,

  questionSize: 24,
  questionColor: "#ffffff",
  questionBgColor: "#0a0a14",
  questionBorderColor: "#ffffff",

  iconColor: "#7a5aff",
  btnColor: "#7a5aff",
  btnTextColor: "#ffffff",

  hudTextColor: "#ffffff",
  hudPanelColor: "#0f0f19",
  scoreSize: 24,
  livesSize: 24,

  fxShadow: false,
  fxNeon: true,
  fxStroke: true,
  fxStrokeNeon: false,
  fxToQuestion: true,
  fxToHud: true,
  fxToAnswers: true,
  fxToPoints: true,
  fxColor: "#ffd84a",
  fxStrength: 7,
  strokeWidth: 0.6,
  strokeColor: "#000000",

  progressHeight: 30,
  progressColor: "#7a5aff",

  playerImg: "",
  playerSize: 86,
  playerShadow: false,

  answerCardImg: "",
  bgImg: "",
  transparentBg: true,

  answerSize: 86,
  answerContentScale: 1,
  answerTextX: 50,
  answerTextY: 64,
  answerTextBgOn: true,

  answerCardFit: "contain",
  answerCardScale: 1,
  answerCardPosX: 50,
  answerCardPosY: 50,

  feedbackCorrect: "Верно!",
  feedbackWrong: "Неверно!",

  livesCount: 3,
  pointsPerCorrect: 10,
  cooldownTurns: 3,
  playerSpeed: 7,

  playerTiltMax: 18,
  playerTiltSmooth: 0.22,

  bgScrollFactor: 0.35,
  bgParallaxY: 18,

  winConfetti: true,
  loseRedTint: 0.10,

  difficulty: {
    easy:   { speed: 2.4, spawnEveryMs: 1050, minXGap: 220, maxOnScreen: 4 },
    medium: { speed: 3.2, spawnEveryMs:  900, minXGap: 200, maxOnScreen: 5 },
    hard:   { speed: 4.1, spawnEveryMs:  760, minXGap: 180, maxOnScreen: 6 },
  },

  questions: [
    { q:"Столица Франции?", answers:[
      {label:"A", text:"Париж",  correct:true},
      {label:"B", text:"Рим",    correct:false},
      {label:"C", text:"Берлин", correct:false},
    ]},
    { q:"2 + 2 = ?", answers:[
      {label:"A", text:"3", correct:false},
      {label:"B", text:"4", correct:true},
      {label:"C", text:"5", correct:false},
    ]},
    { q:"Где больше: 7 или 9?", answers:[
      {label:"A", text:"7", correct:false},
      {label:"B", text:"9", correct:true},
      {label:"C", text:"равны", correct:false},
    ]},
  ]
};

const params = new URLSearchParams(location.search);
const mode = params.get("mode");

if(mode === "play"){
  document.getElementById("gameRoot").style.display = "block";
  startGameMode();
} else {
  document.getElementById("editorApp").style.display = "flex";
  startEditorMode();
}

/* ===== text fx ===== */
function buildFxCss(cfg){
  const s = clampInt(cfg.fxStrength, 1, 12, 7);
  const c = cfg.fxColor || "#ffd84a";

  const shadowParts = [];
  if(cfg.fxShadow){
    const blur = 6 + s*2;
    const y = 2 + Math.floor(s/3);
    shadowParts.push(`0 ${y}px ${blur}px ${hexToRgba("#000000",0.55)}`);
  }
  if(cfg.fxNeon){
    const b1=4+s*1.2, b2=10+s*2.2, b3=18+s*3.2;
    shadowParts.push(`0 0 ${b1}px ${hexToRgba(c,0.85)}`);
    shadowParts.push(`0 0 ${b2}px ${hexToRgba(c,0.65)}`);
    shadowParts.push(`0 0 ${b3}px ${hexToRgba(c,0.45)}`);
  }
  const textShadow = shadowParts.length ? `text-shadow:${shadowParts.join(",")};` : "";

  let stroke = "";
  if(cfg.fxStroke){
    const w = clampNum(cfg.strokeWidth, 0, 3, 0.6);
    stroke += `-webkit-text-stroke:${w}px ${cfg.strokeColor || "#000000"};`;
  }
  if(cfg.fxStrokeNeon){
    const w = clampNum(cfg.strokeWidth, 0, 3, 0.8);
    stroke += `-webkit-text-stroke:${w}px ${c};`;
  }
  return `${textShadow}${stroke}`;
}

/* ================= EDITOR ================= */
function startEditorMode(){
  const els = {
    baseUrl: document.getElementById("baseUrl"),

    fontFamily: document.getElementById("fontFamily"),
    fontWeight: document.getElementById("fontWeight"),
    questionSize: document.getElementById("questionSize"),

    questionColor: document.getElementById("questionColor"),
    questionBgColor: document.getElementById("questionBgColor"),
    questionBorderColor: document.getElementById("questionBorderColor"),

    iconColor: document.getElementById("iconColor"),
    btnColor: document.getElementById("btnColor"),
    btnTextColor: document.getElementById("btnTextColor"),

    hudTextColor: document.getElementById("hudTextColor"),
    hudPanelColor: document.getElementById("hudPanelColor"),
    scoreSize: document.getElementById("scoreSize"),
    livesSize: document.getElementById("livesSize"),

    feedbackCorrect: document.getElementById("feedbackCorrect"),
    feedbackWrong: document.getElementById("feedbackWrong"),

    fxShadow: document.getElementById("fxShadow"),
    fxNeon: document.getElementById("fxNeon"),
    fxStroke: document.getElementById("fxStroke"),
    fxStrokeNeon: document.getElementById("fxStrokeNeon"),
    fxToQuestion: document.getElementById("fxToQuestion"),
    fxToHud: document.getElementById("fxToHud"),
    fxToAnswers: document.getElementById("fxToAnswers"),
    fxToPoints: document.getElementById("fxToPoints"),
    fxColor: document.getElementById("fxColor"),
    fxStrength: document.getElementById("fxStrength"),
    strokeWidth: document.getElementById("strokeWidth"),
    strokeColor: document.getElementById("strokeColor"),

    progressHeight: document.getElementById("progressHeight"),
    progressColor: document.getElementById("progressColor"),

    playerImgUrl: document.getElementById("playerImgUrl"),
    answerCardImgUrl: document.getElementById("answerCardImgUrl"),
    bgImgUrl: document.getElementById("bgImgUrl"),
    playerImgFile: document.getElementById("playerImgFile"),
    answerCardImgFile: document.getElementById("answerCardImgFile"),
    bgImgFile: document.getElementById("bgImgFile"),
    answerImgStatus: document.getElementById("answerImgStatus"),

    transparentBg: document.getElementById("transparentBg"),

    // player
    playerSizeR: document.getElementById("playerSizeR"),
    playerSize: document.getElementById("playerSize"),
    playerShadow: document.getElementById("playerShadow"),

    // answer sliders
    answerSizeR: document.getElementById("answerSizeR"),
    answerSize: document.getElementById("answerSize"),
    answerContentScaleR: document.getElementById("answerContentScaleR"),
    answerContentScale: document.getElementById("answerContentScale"),
    answerTextXR: document.getElementById("answerTextXR"),
    answerTextX: document.getElementById("answerTextX"),
    answerTextYR: document.getElementById("answerTextYR"),
    answerTextY: document.getElementById("answerTextY"),
    answerTextBgOn: document.getElementById("answerTextBgOn"),
    answerCardFit: document.getElementById("answerCardFit"),
    answerCardScaleR: document.getElementById("answerCardScaleR"),
    answerCardScale: document.getElementById("answerCardScale"),
    answerCardPosXR: document.getElementById("answerCardPosXR"),
    answerCardPosX: document.getElementById("answerCardPosX"),
    answerCardPosYR: document.getElementById("answerCardPosYR"),
    answerCardPosY: document.getElementById("answerCardPosY"),

    livesCount: document.getElementById("livesCount"),
    pointsPerCorrect: document.getElementById("pointsPerCorrect"),
    cooldownTurns: document.getElementById("cooldownTurns"),
    playerSpeed: document.getElementById("playerSpeed"),

    questionsList: document.getElementById("questionsList"),
    addQuestionBtn: document.getElementById("addQuestionBtn"),
    resetQuestionsBtn: document.getElementById("resetQuestionsBtn"),

    applyPreviewBtn: document.getElementById("applyPreviewBtn"),
    genIframeBtn: document.getElementById("genIframeBtn"),
    copyIframeBtn: document.getElementById("copyIframeBtn"),
    codeBox: document.getElementById("codeBox"),

    previewFrame: document.getElementById("previewFrame"),
    cfgSizeBadge: document.getElementById("cfgSizeBadge"),

    // answer preview
    answerPreviewOrb: document.getElementById("answerPreviewOrb"),
    answerPreviewImg: document.getElementById("answerPreviewImg"),
    answerPreviewLayer: document.getElementById("answerPreviewLayer"),
    answerPreviewText: document.getElementById("answerPreviewText"),
    answerPreviewTextInput: document.getElementById("answerPreviewTextInput"),
  };

  // baseUrl по умолчанию (на всякий случай)
  els.baseUrl.value = location.origin + location.pathname;

  let cfgDraft = deepClone(DEFAULT_CFG);
  let cfgApplied = deepClone(DEFAULT_CFG);

  function makeEmptyQuestion(){
    return { q:"", answers:[
      {label:"A", text:"", correct:true},
      {label:"B", text:"", correct:false},
      {label:"C", text:"", correct:false},
    ]};
  }
  function nextLabel(arr){
    const base="ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    const used=new Set(arr.map(x=>String(x.label||"").trim().toUpperCase()));
    for(const c of base){ if(!used.has(c)) return c; }
    return "X";
  }

  function refreshAnswerImgStatus(){
    const has = !!cfgDraft.answerCardImg;
    const kind = has ? (cfgDraft.answerCardImg.startsWith("data:") ? "файл (dataURL)" : "URL") : "нет";
    els.answerImgStatus.textContent = `Статус: ${kind}`;
  }

  function cfgToUI(){
    els.fontFamily.value = cfgDraft.fontFamily;
    els.fontWeight.value = String(cfgDraft.fontWeight);
    els.questionSize.value = cfgDraft.questionSize;

    els.questionColor.value = cfgDraft.questionColor;
    els.questionBgColor.value = cfgDraft.questionBgColor;
    els.questionBorderColor.value = cfgDraft.questionBorderColor;

    els.iconColor.value = cfgDraft.iconColor;
    els.btnColor.value = cfgDraft.btnColor;
    els.btnTextColor.value = cfgDraft.btnTextColor;

    els.hudTextColor.value = cfgDraft.hudTextColor;
    els.hudPanelColor.value = cfgDraft.hudPanelColor;
    els.scoreSize.value = cfgDraft.scoreSize;
    els.livesSize.value = cfgDraft.livesSize;

    els.feedbackCorrect.value = cfgDraft.feedbackCorrect || "Верно!";
    els.feedbackWrong.value = cfgDraft.feedbackWrong || "Неверно!";

    els.fxShadow.checked = !!cfgDraft.fxShadow;
    els.fxNeon.checked = !!cfgDraft.fxNeon;
    els.fxStroke.checked = !!cfgDraft.fxStroke;
    els.fxStrokeNeon.checked = !!cfgDraft.fxStrokeNeon;
    els.fxToQuestion.checked = cfgDraft.fxToQuestion !== false;
    els.fxToHud.checked = cfgDraft.fxToHud !== false;
    els.fxToAnswers.checked = cfgDraft.fxToAnswers !== false;
    els.fxToPoints.checked = cfgDraft.fxToPoints !== false;
    els.fxColor.value = cfgDraft.fxColor || "#ffd84a";
    els.fxStrength.value = cfgDraft.fxStrength ?? 7;
    els.strokeWidth.value = cfgDraft.strokeWidth ?? 0.6;
    els.strokeColor.value = cfgDraft.strokeColor || "#000000";

    els.progressHeight.value = cfgDraft.progressHeight;
    els.progressColor.value = cfgDraft.progressColor;

    els.playerImgUrl.value = (cfgDraft.playerImg && cfgDraft.playerImg.startsWith("http")) ? cfgDraft.playerImg : "";
    els.answerCardImgUrl.value = (cfgDraft.answerCardImg && cfgDraft.answerCardImg.startsWith("http")) ? cfgDraft.answerCardImg : "";
    els.bgImgUrl.value = (cfgDraft.bgImg && cfgDraft.bgImg.startsWith("http")) ? cfgDraft.bgImg : "";
    els.transparentBg.value = cfgDraft.transparentBg ? "1" : "0";

    pairSync(els.playerSizeR, els.playerSize, cfgDraft.playerSize ?? 86);
    els.playerShadow.checked = !!cfgDraft.playerShadow;

    pairSync(els.answerSizeR, els.answerSize, cfgDraft.answerSize ?? 86);
    pairSync(els.answerContentScaleR, els.answerContentScale, cfgDraft.answerContentScale ?? 1);
    pairSync(els.answerTextXR, els.answerTextX, cfgDraft.answerTextX ?? 50);
    pairSync(els.answerTextYR, els.answerTextY, cfgDraft.answerTextY ?? 64);
    els.answerTextBgOn.checked = cfgDraft.answerTextBgOn !== false;

    els.answerCardFit.value = cfgDraft.answerCardFit || "contain";
    pairSync(els.answerCardScaleR, els.answerCardScale, cfgDraft.answerCardScale ?? 1);
    pairSync(els.answerCardPosXR, els.answerCardPosX, cfgDraft.answerCardPosX ?? 50);
    pairSync(els.answerCardPosYR, els.answerCardPosY, cfgDraft.answerCardPosY ?? 50);

    els.livesCount.value = cfgDraft.livesCount;
    els.pointsPerCorrect.value = cfgDraft.pointsPerCorrect;
    els.cooldownTurns.value = cfgDraft.cooldownTurns;
    els.playerSpeed.value = cfgDraft.playerSpeed;

    refreshAnswerImgStatus();
  }

  function renderQuestions(){
    els.questionsList.innerHTML = "";
    cfgDraft.questions.forEach((q, qi)=>{
      const wrap = document.createElement("div");
      wrap.className = "qitem";

      const top = document.createElement("div");
      top.className = "qtop";

      const title = document.createElement("strong");
      title.textContent = `Вопрос ${qi+1}`;

      const delQ = document.createElement("button");
      delQ.className = "btn miniBtn danger";
      delQ.textContent = "Удалить";
      delQ.onclick = ()=>{
        cfgDraft.questions.splice(qi,1);
        if(cfgDraft.questions.length === 0) cfgDraft.questions.push(makeEmptyQuestion());
        renderQuestions();
      };

      top.appendChild(title); top.appendChild(delQ);

      const qInput = document.createElement("input");
      qInput.type = "text";
      qInput.value = q.q || "";
      qInput.placeholder = "Текст вопроса...";
      qInput.oninput = ()=>{ cfgDraft.questions[qi].q = qInput.value; };

      const answers = document.createElement("div");
      answers.className = "answers";

      cfgDraft.questions[qi].answers.forEach((a, ai)=>{
        const row = document.createElement("div");
        row.className = "ansRow";

        const lab = document.createElement("input");
        lab.type = "text";
        lab.value = a.label || "";
        lab.placeholder = "A";
        lab.oninput = ()=>{ cfgDraft.questions[qi].answers[ai].label = lab.value; };

        const txt = document.createElement("input");
        txt.type = "text";
        txt.value = a.text || "";
        txt.placeholder = "Текст варианта...";
        txt.oninput = ()=>{ cfgDraft.questions[qi].answers[ai].text = txt.value; };

        const right = document.createElement("div");
        right.className = "chk";
        const chk = document.createElement("input");
        chk.type = "checkbox";
        chk.checked = !!a.correct;
        chk.onchange = ()=>{
          cfgDraft.questions[qi].answers.forEach(x=>x.correct=false);
          cfgDraft.questions[qi].answers[ai].correct = chk.checked;
          renderQuestions();
        };
        right.appendChild(chk);
        right.appendChild(Object.assign(document.createElement("span"), {textContent:"верный"}));

        row.appendChild(lab); row.appendChild(txt); row.appendChild(right);
        answers.appendChild(row);
      });

      const qButtons = document.createElement("div");
      qButtons.className = "row";
      qButtons.style.marginTop = "10px";

      const addA = document.createElement("button");
      addA.className = "btn miniBtn";
      addA.textContent = "+ Вариант";
      addA.onclick = ()=>{
        cfgDraft.questions[qi].answers.push({label: nextLabel(cfgDraft.questions[qi].answers), text:"", correct:false});
        renderQuestions();
      };

      const delA = document.createElement("button");
      delA.className = "btn miniBtn danger";
      delA.textContent = "− Вариант";
      delA.onclick = ()=>{
        if(cfgDraft.questions[qi].answers.length <= 2) return;
        cfgDraft.questions[qi].answers.pop();
        if(!cfgDraft.questions[qi].answers.some(x=>x.correct)) cfgDraft.questions[qi].answers[0].correct = true;
        renderQuestions();
      };

      qButtons.appendChild(addA); qButtons.appendChild(delA);

      wrap.appendChild(top);
      wrap.appendChild(qInput);
      wrap.appendChild(document.createElement("div")).className="hr";
      wrap.appendChild(answers);
      wrap.appendChild(qButtons);

      els.questionsList.appendChild(wrap);
    });
  }

  async function fileToDataUrl(file){
    return new Promise((res, rej)=>{
      const r = new FileReader();
      r.onload = ()=>res(String(r.result||""));
      r.onerror = rej;
      r.readAsDataURL(file);
    });
  }

  function readUIIntoDraft(){
    cfgDraft.fontFamily = els.fontFamily.value;
    cfgDraft.fontWeight = Number(els.fontWeight.value || 900);
    cfgDraft.questionSize = Number(els.questionSize.value || 24);

    cfgDraft.questionColor = els.questionColor.value;
    cfgDraft.questionBgColor = els.questionBgColor.value;
    cfgDraft.questionBorderColor = els.questionBorderColor.value;

    cfgDraft.iconColor = els.iconColor.value;
    cfgDraft.btnColor = els.btnColor.value;
    cfgDraft.btnTextColor = els.btnTextColor.value;

    cfgDraft.hudTextColor = els.hudTextColor.value;
    cfgDraft.hudPanelColor = els.hudPanelColor.value;
    cfgDraft.scoreSize = Number(els.scoreSize.value || 24);
    cfgDraft.livesSize = Number(els.livesSize.value || 24);

    cfgDraft.feedbackCorrect = els.feedbackCorrect.value || "Верно!";
    cfgDraft.feedbackWrong = els.feedbackWrong.value || "Неверно!";

    cfgDraft.fxShadow = els.fxShadow.checked;
    cfgDraft.fxNeon = els.fxNeon.checked;
    cfgDraft.fxStroke = els.fxStroke.checked;
    cfgDraft.fxStrokeNeon = els.fxStrokeNeon.checked;

    cfgDraft.fxToQuestion = els.fxToQuestion.checked;
    cfgDraft.fxToHud = els.fxToHud.checked;
    cfgDraft.fxToAnswers = els.fxToAnswers.checked;
    cfgDraft.fxToPoints = els.fxToPoints.checked;

    cfgDraft.fxColor = els.fxColor.value;
    cfgDraft.fxStrength = Number(els.fxStrength.value || 7);
    cfgDraft.strokeWidth = Number(els.strokeWidth.value || 0.6);
    cfgDraft.strokeColor = els.strokeColor.value;

    cfgDraft.progressHeight = Number(els.progressHeight.value || 30);
    cfgDraft.progressColor = els.progressColor.value;

    cfgDraft.transparentBg = els.transparentBg.value === "1";

    cfgDraft.playerSize = Number(els.playerSize.value || 86);
    cfgDraft.playerShadow = els.playerShadow.checked;

    cfgDraft.answerSize = Number(els.answerSize.value || 86);
    cfgDraft.answerContentScale = Number(els.answerContentScale.value || 1);
    cfgDraft.answerTextX = Number(els.answerTextX.value || 50);
    cfgDraft.answerTextY = Number(els.answerTextY.value || 64);
    cfgDraft.answerTextBgOn = els.answerTextBgOn.checked;

    cfgDraft.answerCardFit = els.answerCardFit.value;
    cfgDraft.answerCardScale = Number(els.answerCardScale.value || 1);
    cfgDraft.answerCardPosX = Number(els.answerCardPosX.value || 50);
    cfgDraft.answerCardPosY = Number(els.answerCardPosY.value || 50);

    cfgDraft.livesCount = Number(els.livesCount.value || 3);
    cfgDraft.pointsPerCorrect = Number(els.pointsPerCorrect.value || 10);
    cfgDraft.cooldownTurns = Number(els.cooldownTurns.value || 3);
    cfgDraft.playerSpeed = Number(els.playerSpeed.value || 7);

    if(els.playerImgUrl.value.trim().startsWith("http")) cfgDraft.playerImg = els.playerImgUrl.value.trim();
    if(els.answerCardImgUrl.value.trim().startsWith("http")) cfgDraft.answerCardImg = els.answerCardImgUrl.value.trim();
    if(els.bgImgUrl.value.trim().startsWith("http")) cfgDraft.bgImg = els.bgImgUrl.value.trim();

    refreshAnswerImgStatus();
  }

  function buildCfgParam(fromCfg){
    const c = deepClone(fromCfg);
    if(!c.questions?.length) c.questions = [makeEmptyQuestion()];
    c.questions.forEach(q=>{
      if(!q.answers?.length) q.answers = [{label:"A", text:"", correct:true},{label:"B", text:"", correct:false}];
      if(!q.answers.some(a=>a.correct)) q.answers[0].correct = true;
    });
    return b64urlEncode(JSON.stringify(c));
  }

  // ПРЕДПРОСМОТР: всегда текущий файл, чтобы изменения кода были видны сразу
  function buildPlayUrlForPreview(fromCfg){
    const base = location.origin + location.pathname;
    const enc = buildCfgParam(fromCfg);
    els.cfgSizeBadge.textContent = `cfg: ${Math.round(enc.length/1024*10)/10}KB`;
    return `${base}?mode=play&cfg=${enc}&v=${Date.now()}`;
  }
  // IFRAME: берём baseUrl (GitHub Pages)
  function buildPlayUrlForIframe(fromCfg){
    const base = els.baseUrl.value.trim() || (location.origin + location.pathname);
    const enc = buildCfgParam(fromCfg);
    els.cfgSizeBadge.textContent = `cfg: ${Math.round(enc.length/1024*10)/10}KB`;
    return `${base}?mode=play&cfg=${enc}&v=${Date.now()}`;
  }

  function updateAnswerPreview(){
    const size = Number(cfgDraft.answerSize || 86);
    els.answerPreviewOrb.style.width = size + "px";
    els.answerPreviewOrb.style.height = size + "px";

    const img = cfgDraft.answerCardImg || "";
    els.answerPreviewImg.style.backgroundImage = img ? `url('${cssUrl(img)}')` : "none";
    els.answerPreviewImg.style.backgroundSize = cfgDraft.answerCardFit || "contain";
    els.answerPreviewImg.style.backgroundPosition = `${cfgDraft.answerCardPosX ?? 50}% ${cfgDraft.answerCardPosY ?? 50}%`;
    els.answerPreviewImg.style.transform = `scale(${cfgDraft.answerCardScale ?? 1})`;

    els.answerPreviewLayer.style.transform = `scale(${cfgDraft.answerContentScale ?? 1})`;

    els.answerPreviewText.style.left  = (cfgDraft.answerTextX ?? 50) + "%";
    els.answerPreviewText.style.top   = (cfgDraft.answerTextY ?? 64) + "%";

    const t = (els.answerPreviewTextInput?.value || "Текст варианта");
    els.answerPreviewText.textContent = t;

    // подложка текста
    if(cfgDraft.answerTextBgOn){
      els.answerPreviewText.style.padding = "4px 8px";
      els.answerPreviewText.style.background = "rgba(0,0,0,.18)";
      els.answerPreviewText.style.border = "1px solid rgba(255,255,255,.10)";
    }else{
      els.answerPreviewText.style.padding = "0";
      els.answerPreviewText.style.background = "transparent";
      els.answerPreviewText.style.border = "none";
    }

    // эффекты текста на ответы
    const fx = buildFxCss(cfgDraft);
    const fxAns = (cfgDraft.fxToAnswers !== false) ? fx : "";
    // сбросим только то, что мы контролируем (просто перезапишем стили добавкой)
    // (не делаем сложный парсинг)
    els.answerPreviewText.style.webkitTextStroke = "";
    els.answerPreviewText.style.textShadow = "";
    if(fxAns.includes("text-shadow:")){
      const m = fxAns.match(/text-shadow:([^;]+);/);
      if(m) els.answerPreviewText.style.textShadow = m[1].trim();
    }
    if(fxAns.includes("-webkit-text-stroke:")){
      const m2 = fxAns.match(/-webkit-text-stroke:([^;]+);/);
      if(m2) els.answerPreviewText.style.webkitTextStroke = m2[1].trim();
    }
  }

  function updateSilent(){
    readUIIntoDraft();
    updateAnswerPreview();
  }

  function applyPreview(){
    readUIIntoDraft();
    cfgApplied = deepClone(cfgDraft);
    const url = buildPlayUrlForPreview(cfgApplied);

    // жёсткий сброс iframe (анти-кэш/анти-залипание)
    els.previewFrame.src = "about:blank";
    requestAnimationFrame(()=>{ els.previewFrame.src = url; });
  }

  // bindings
  const bindInputs = [
    els.baseUrl,
    els.fontFamily, els.fontWeight, els.questionSize,
    els.questionColor, els.questionBgColor, els.questionBorderColor,
    els.iconColor, els.btnColor, els.btnTextColor,
    els.hudTextColor, els.hudPanelColor, els.scoreSize, els.livesSize,
    els.feedbackCorrect, els.feedbackWrong,
    els.fxShadow, els.fxNeon, els.fxStroke, els.fxStrokeNeon,
    els.fxToQuestion, els.fxToHud, els.fxToAnswers, els.fxToPoints,
    els.fxColor, els.fxStrength, els.strokeWidth, els.strokeColor,
    els.progressHeight, els.progressColor,
    els.transparentBg,
    els.answerTextBgOn,
    els.answerCardFit,
    els.livesCount, els.pointsPerCorrect, els.cooldownTurns, els.playerSpeed,
    els.playerImgUrl, els.answerCardImgUrl, els.bgImgUrl,
    els.playerShadow
  ];
  bindInputs.forEach(el=>{
    el.addEventListener("input", updateSilent);
    el.addEventListener("change", updateSilent);
  });

  pairBind(els.playerSizeR, els.playerSize, updateSilent);
  pairBind(els.answerSizeR, els.answerSize, updateSilent);
  pairBind(els.answerContentScaleR, els.answerContentScale, updateSilent);
  pairBind(els.answerTextXR, els.answerTextX, updateSilent);
  pairBind(els.answerTextYR, els.answerTextY, updateSilent);
  pairBind(els.answerCardScaleR, els.answerCardScale, updateSilent);
  pairBind(els.answerCardPosXR, els.answerCardPosX, updateSilent);
  pairBind(els.answerCardPosYR, els.answerCardPosY, updateSilent);

  els.answerPreviewTextInput.addEventListener("input", updateAnswerPreview);
  els.answerPreviewTextInput.addEventListener("change", updateAnswerPreview);

  els.playerImgFile.addEventListener("change", async ()=>{
    const f = els.playerImgFile.files?.[0]; if(!f) return;
    cfgDraft.playerImg = await fileToDataUrl(f);
    els.playerImgUrl.value = "";
    updateSilent();
  });
  els.answerCardImgFile.addEventListener("change", async ()=>{
    const f = els.answerCardImgFile.files?.[0]; if(!f) return;
    cfgDraft.answerCardImg = await fileToDataUrl(f);
    els.answerCardImgUrl.value = "";
    updateSilent();
  });
  els.bgImgFile.addEventListener("change", async ()=>{
    const f = els.bgImgFile.files?.[0]; if(!f) return;
    cfgDraft.bgImg = await fileToDataUrl(f);
    els.bgImgUrl.value = "";
    updateSilent();
  });

  els.addQuestionBtn.onclick = ()=>{
    cfgDraft.questions.push(makeEmptyQuestion());
    renderQuestions();
  };

  els.resetQuestionsBtn.onclick = ()=>{
    cfgDraft = deepClone(DEFAULT_CFG);
    cfgApplied = deepClone(DEFAULT_CFG);
    cfgToUI(); renderQuestions();
    els.codeBox.value = "";
    updateSilent();
    applyPreview();
  };

  els.applyPreviewBtn.onclick = ()=>{ applyPreview(); };

  els.genIframeBtn.onclick = ()=>{
    readUIIntoDraft();
    cfgApplied = deepClone(cfgDraft);
    const src = buildPlayUrlForIframe(cfgApplied);
    els.codeBox.value =
`<iframe src="${src}"
        style="width:100%;height:650px;border:0;background:transparent"
        width="100%" height="650"></iframe>`;
  };

  els.copyIframeBtn.onclick = async ()=>{
    const text = els.codeBox.value.trim();
    if(!text) return;
    try{
      await navigator.clipboard.writeText(text);
      els.copyIframeBtn.textContent = "Скопировано!";
      setTimeout(()=>els.copyIframeBtn.textContent="Скопировать", 900);
    }catch(e){
      els.copyIframeBtn.textContent = "Не удалось";
      setTimeout(()=>els.copyIframeBtn.textContent="Скопировать", 900);
    }
  };

  // init
  cfgToUI();
  renderQuestions();
  updateSilent();
  applyPreview();
}

/* ================= GAME ================= */
function normalizeCfg(cfg){
  const out = deepClone(DEFAULT_CFG);
  Object.assign(out, cfg || {});

  if(!Array.isArray(out.questions) || out.questions.length === 0) out.questions = deepClone(DEFAULT_CFG.questions);
  out.questions = out.questions.map(q=>{
    const qq = { q: String(q.q||""), answers: Array.isArray(q.answers)?q.answers:[] };
    qq.answers = qq.answers.map(a=>({label:String(a.label||""), text:String(a.text||""), correct:!!a.correct}));
    if(qq.answers.length < 2) qq.answers = [{label:"A", text:"", correct:true},{label:"B", text:"", correct:false}];
    if(!qq.answers.some(a=>a.correct)) qq.answers[0].correct = true;
    return qq;
  });

  out.livesCount = clampInt(out.livesCount, 1, 10, 3);
  out.pointsPerCorrect = clampInt(out.pointsPerCorrect, 1, 200, 10);
  out.cooldownTurns = clampInt(out.cooldownTurns, 0, 10, 3);
  out.playerSpeed = clampInt(out.playerSpeed, 3, 18, 7);

  out.questionSize = clampInt(out.questionSize, 12, 70, 24);
  out.scoreSize = clampInt(out.scoreSize, 12, 70, 24);
  out.livesSize = clampInt(out.livesSize, 12, 70, 24);

  out.playerSize = clampInt(out.playerSize, 56, 180, 86);
  out.playerShadow = !!out.playerShadow;

  out.answerSize = clampInt(out.answerSize, 56, 220, 86);
  out.answerContentScale = clampNum(out.answerContentScale, 0.6, 1.6, 1);
  out.answerTextX  = clampNum(out.answerTextX, 0, 100, 50);
  out.answerTextY  = clampNum(out.answerTextY, 0, 100, 64);
  out.answerTextBgOn = out.answerTextBgOn !== false;

  out.answerCardFit = ["contain","cover"].includes(out.answerCardFit) ? out.answerCardFit : "contain";
  out.answerCardScale = clampNum(out.answerCardScale, 0.6, 2, 1);
  out.answerCardPosX = clampNum(out.answerCardPosX, 0, 100, 50);
  out.answerCardPosY = clampNum(out.answerCardPosY, 0, 100, 50);

  out.fxStrength = clampInt(out.fxStrength, 1, 12, 7);
  out.strokeWidth = clampNum(out.strokeWidth, 0, 3, 0.6);

  out.feedbackCorrect = String(out.feedbackCorrect || "Верно!");
  out.feedbackWrong = String(out.feedbackWrong || "Неверно!");

  out.playerTiltMax = clampNum(out.playerTiltMax, 0, 35, 18);
  out.playerTiltSmooth = clampNum(out.playerTiltSmooth, 0.01, 0.6, 0.22);

  out.bgScrollFactor = clampNum(out.bgScrollFactor, 0, 3, 0.35);
  out.bgParallaxY = clampNum(out.bgParallaxY, 0, 80, 18);

  out.winConfetti = out.winConfetti !== false;
  out.loseRedTint = clampNum(out.loseRedTint, 0, 0.25, 0.10);

  out.lives = out.livesCount;
  return out;
}

function startGameMode(){
  const root = document.getElementById("gameRoot");

  let cfg = deepClone(DEFAULT_CFG);
  const params = new URLSearchParams(location.search);
  const cfgParam = params.get("cfg");
  if(cfgParam){
    try{ cfg = Object.assign(cfg, JSON.parse(b64urlDecode(cfgParam))); }catch(e){}
  }
  const CFG = normalizeCfg(cfg);

  const fxCSS = buildFxCss(CFG);
  const fxQ = CFG.fxToQuestion ? fxCSS : "";
  const fxHud = CFG.fxToHud ? fxCSS : "";
  const fxAns = CFG.fxToAnswers ? fxCSS : "";
  const fxPts = CFG.fxToPoints ? fxCSS : "";

  root.innerHTML = `
    <style>
      html,body{margin:0;height:100%;background:transparent!important;overflow:hidden;}
      #wrap{position:relative;width:100%;height:100%;background:transparent;touch-action:none;}
      #bg{position:absolute; inset:0; z-index:0; overflow:hidden; background:transparent;}
      #bgLayer{
        position:absolute; inset:-40px;
        background: ${CFG.transparentBg ? "transparent" : (CFG.bgImg ? `url('${cssUrl(CFG.bgImg)}') 0 50% / auto 110% repeat-x` : "transparent")};
        will-change: background-position, transform;
        transform: scale(1.05);
      }

      #loseTint{
        position:absolute; inset:0;
        background: rgba(255, 60, 60, ${clampNum(CFG.loseRedTint,0,0.25,0.10)});
        opacity: 0;
        pointer-events:none;
        z-index: 200;
        transition: opacity .35s ease;
      }
      #loseTint.on{ opacity: 1; }

      #fxCanvas{
        position:absolute; inset:0;
        z-index: 260;
        pointer-events:none;
      }

      #cfgDebug{
        position:absolute; right:12px; bottom:12px;
        z-index:700;
        font-size:12px;
        padding:8px 10px;
        border-radius:999px;
        background: rgba(0,0,0,.35);
        border:1px solid rgba(255,255,255,.18);
        color: rgba(255,255,255,.9);
        pointer-events:none;
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
      }

      #game{position:absolute; inset:0; z-index:1; font-family:${escapeCss(CFG.fontFamily)};}

      #topbar{
        position:absolute; top:14px; left:14px; right:14px;
        display:flex; align-items:flex-start; justify-content:space-between;
        gap:12px; z-index:120; pointer-events:none;
      }
      .pill{
        background: ${hexToRgba(CFG.hudPanelColor, 0.70)};
        border: 1px solid rgba(255,255,255,.18);
        border-radius: 999px;
        padding: 14px 16px;
        box-shadow: 0 16px 60px rgba(0,0,0,.42);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        display:flex; gap:12px; align-items:center;
        white-space:nowrap;
        color: ${CFG.hudTextColor};
        ${fxHud}
      }
      .pill .label{font-size:14px;color:${hexToRgba(CFG.hudTextColor, 0.75)};font-weight:${CFG.fontWeight};}
      .pill .value{font-size:${CFG.scoreSize}px;font-weight:${CFG.fontWeight};}
      #lives{font-size:${CFG.livesSize}px;letter-spacing:1px;color:${CFG.hudTextColor};}

      #questionWrap{
        position:absolute; top:78px; left:50%; transform:translateX(-50%);
        z-index:110; pointer-events:none;
        max-width:min(980px, calc(100% - 28px));
      }
      #questionBox{
        background: ${hexToRgba(CFG.questionBgColor, 0.72)};
        border: 1px solid ${hexToRgba(CFG.questionBorderColor, 0.42)};
        border-radius: 999px;
        padding: 16px 20px;
        box-shadow: 0 16px 60px rgba(0,0,0,.42);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        text-align:center;
        font-weight:${CFG.fontWeight};
        font-size:${CFG.questionSize}px;
        color: ${CFG.questionColor};
        white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
        ${fxQ}
      }

      #scene{position:absolute; inset:0; overflow:hidden;}
      .orb{
        position:absolute;
        border-radius: 999px;
        display:flex; align-items:center; justify-content:center;
        user-select:none;
        will-change: transform, left, top;
      }

      /* ===== игрок: без обводки ===== */
      #player{
        width: ${CFG.playerSize}px; height: ${CFG.playerSize}px;
        left:92px; top:50%;
        transform:translate(-50%,-50%) rotate(var(--tilt, 0deg));
        transform-origin: 50% 50%;
        transition: transform 0.06s linear;
        background: rgba(120,90,255,.12);
        border: none;
        box-shadow: ${CFG.playerShadow ? "0 12px 40px rgba(0,0,0,.30), 0 0 26px rgba(120,90,255,.22)" : "none"};
        filter: ${CFG.playerShadow ? "drop-shadow(0 0 14px rgba(120,90,255,.18))" : "none"};
        overflow:hidden;
      }
      #playerInner{
        width:100%;height:100%;
        animation: playerBob 1.15s ease-in-out infinite;
      }
      @keyframes playerBob{
        0%{ transform: translateY(0px) scale(1); }
        50%{ transform: translateY(-6px) scale(1); }
        100%{ transform: translateY(0px) scale(1); }
      }
      #player.okPulse #playerInner{ animation: okPulse .26s ease-out 1; }
      @keyframes okPulse{
        0%{ transform: translateY(-2px) scale(1); }
        60%{ transform: translateY(-8px) scale(1.10); }
        100%{ transform: translateY(-2px) scale(1); }
      }
      #player .img{
        width:100%;height:100%;
        background-size:cover;background-position:center;
        border-radius:999px;
        opacity:${CFG.playerImg ? 1 : 0};
      }

      /* ===== ответы: без подложки (картинка — фон) ===== */
      .answer{
        width:${CFG.answerSize}px; height:${CFG.answerSize}px;
        background: transparent;
        border: none;
        box-shadow: none;
        overflow: visible;
      }
      .answer::before{
        content:"";
        position:absolute; inset:0;
        background-image: ${CFG.answerCardImg ? `url('${cssUrl(CFG.answerCardImg)}')` : "none"};
        background-repeat:no-repeat;
        background-size:${CFG.answerCardFit};
        background-position:${CFG.answerCardPosX}% ${CFG.answerCardPosY}%;
        transform: scale(${CFG.answerCardScale});
        border-radius: 999px;
      }

      .ansLayer{
        position:absolute; inset:0;
        transform: scale(${CFG.answerContentScale});
        transform-origin: 50% 50%;
        pointer-events:none;
      }

      .answer .txt{
        position:absolute;
        left:${CFG.answerTextX}%;
        top:${CFG.answerTextY}%;
        transform: translate(-50%,-50%);
        font-weight:${Math.max(500, Math.min(900, CFG.fontWeight))};
        font-size:13px; line-height:1.12;
        max-width: 210px;
        white-space:normal; word-break:break-word;
        padding: ${CFG.answerTextBgOn ? "4px 8px" : "0"};
        border-radius: 10px;
        background: ${CFG.answerTextBgOn ? "rgba(0,0,0,.18)" : "transparent"};
        border: ${CFG.answerTextBgOn ? "1px solid rgba(255,255,255,.10)" : "none"};
        text-shadow: 0 10px 22px rgba(0,0,0,.55);
        ${fxAns}
      }

      .answer.blinkBad{
        animation: badBlink .22s ease-in-out 2;
        filter: drop-shadow(0 0 16px rgba(255,107,107,.28)) saturate(1.2);
      }
      @keyframes badBlink{
        0%{ transform: translate(-50%,-50%) scale(1); opacity:1; }
        50%{ transform: translate(-50%,-50%) scale(1.06); opacity:.85; }
        100%{ transform: translate(-50%,-50%) scale(1); opacity:1; }
      }

      .pop{
        position:absolute;
        font-weight:${CFG.fontWeight};
        font-size:24px;
        pointer-events:none;
        transform:translate(-50%,-50%);
        color: #ffd84a;
        text-shadow:
          0 0 10px rgba(255,216,74,.90),
          0 0 24px rgba(255,216,74,.70),
          0 16px 36px rgba(0,0,0,.55);
        animation: popUp .78s ease-out forwards;
        z-index:140;
        ${fxPts}
      }
      @keyframes popUp{
        0%{opacity:0;transform:translate(-50%,-50%) scale(.9);}
        15%{opacity:1;transform:translate(-50%,-62%) scale(1.05);}
        100%{opacity:0;transform:translate(-50%,-112%) scale(1);}
      }

      #feedback{
        position:absolute; inset:0;
        display:flex; align-items:center; justify-content:center;
        font-size:34px;font-weight:${CFG.fontWeight};
        pointer-events:none;
        opacity:0; transition:.18s;
        z-index:130;
        text-shadow: 0 16px 36px rgba(0,0,0,.55);
        color: rgba(255,255,255,.92);
      }
      #feedback.show{opacity:1;}

      #progressWrap{
        position:absolute; left:14px; right:14px; bottom:14px;
        z-index:115; pointer-events:none;
      }
      #progressBar{
        height: ${CFG.progressHeight}px;
        border-radius: 999px;
        background: rgba(0,0,0,.14);
        border: 1px solid rgba(255,255,255,.22);
        box-shadow: 0 16px 60px rgba(0,0,0,.42);
        overflow:hidden;
        position:relative;
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
      }
      #progressFill{
        height:100%; width:0%;
        background: ${CFG.progressColor};
        border-radius:999px;
        transition: width .25s ease;
      }
      #progressText{
        position:absolute; inset:0;
        display:flex; align-items:center; justify-content:center;
        font-size:14px; font-weight:${CFG.fontWeight};
        color: rgba(255,255,255,.96);
        text-shadow:0 10px 22px rgba(0,0,0,.5);
        ${fxHud}
      }

      .overlay{
        position:absolute; inset:0;
        display:none;
        align-items:center; justify-content:center;
        z-index:300;
        background: rgba(0,0,0,.55);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
        pointer-events:auto;
      }
      .overlay.show{display:flex;}
      .card{
        width:min(600px, calc(100% - 28px));
        background: rgba(20,18,34,.78);
        border: 1px solid rgba(255,255,255,.18);
        border-radius: 22px;
        box-shadow: 0 16px 60px rgba(0,0,0,.42);
        padding: 18px 18px 16px;
        color: rgba(255,255,255,.92);
      }
      .card h2{margin:0 0 8px;font-size:22px;font-weight:${CFG.fontWeight};display:flex;gap:10px;align-items:center;}
      .card p{margin:0 0 12px;font-size:14px;line-height:1.35;opacity:.9;}

      .icon{
        width:28px;height:28px;border-radius:999px;
        display:inline-flex;align-items:center;justify-content:center;
        background: rgba(255,255,255,.10);
        border: 1px solid rgba(255,255,255,.18);
      }
      .icon svg{width:18px;height:18px;fill:${CFG.iconColor};}

      .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;}
      .chips{display:flex;gap:8px;flex-wrap:wrap;}
      .chipBtn{
        background: rgba(255,255,255,.10);
        border: 1px solid rgba(255,255,255,.18);
        border-radius: 999px;
        padding: 10px 14px;
        font-weight:${CFG.fontWeight};
        font-size:13px;
        color: rgba(255,255,255,.92);
        cursor:pointer;
        user-select:none;
      }
      .chipBtn.active{
        background: rgba(120,90,255,.32);
        border-color: rgba(120,90,255,.45);
      }
      .btn{
        background: rgba(255,255,255,.12);
        border: 1px solid rgba(255,255,255,.20);
        border-radius: 14px;
        padding: 12px 16px;
        font-weight:${CFG.fontWeight};
        color: rgba(255,255,255,.95);
        cursor:pointer;
        user-select:none;
        white-space:nowrap;
        font-size:14px;
      }
      .btn.primary{
        background: ${hexToRgba(CFG.btnColor, 0.55)};
        border-color: ${hexToRgba(CFG.btnColor, 0.72)};
        color: ${CFG.btnTextColor};
      }
      .hint{margin-top:10px;font-size:12px;opacity:.75;}
    </style>

    <div id="wrap">
      <div id="bg"><div id="bgLayer"></div></div>
      <div id="loseTint"></div>
      <canvas id="fxCanvas"></canvas>

      <div id="cfgDebug"></div>

      <div id="game">
        <div id="topbar">
          <div class="pill"><div class="label">Очки</div><div class="value" id="score">0</div></div>
          <div class="pill" id="lives">❤️❤️❤️</div>
        </div>

        <div id="questionWrap"><div id="questionBox">—</div></div>

        <div id="scene">
          <div class="orb" id="player">
            <div id="playerInner">
              <div class="img" id="playerImg"></div>
            </div>
          </div>
        </div>

        <div id="feedback"></div>

        <div id="progressWrap">
          <div id="progressBar">
            <div id="progressFill"></div>
            <div id="progressText">Вопрос 1 из 1</div>
          </div>
        </div>

        <div id="startOverlay" class="overlay show">
          <div class="card">
            <h2>
              <span class="icon" aria-hidden="true">
                <svg viewBox="0 0 24 24"><path d="M12 2l3 7h7l-5.5 4.2L18 21l-6-4-6 4 1.5-7.8L2 9h7z"/></svg>
              </span>
              Задача игрока
            </h2>
            <p>Лови <b>правильный ответ</b> на вопрос сверху. Управление: <b>↑</b>/<b>↓</b> или <b>сенсор</b> (перетаскивание).</p>
            <div class="row">
              <div class="chips">
                <div class="chipBtn active" data-level="easy">Лёгкий</div>
                <div class="chipBtn" data-level="medium">Средний</div>
                <div class="chipBtn" data-level="hard">Сложный</div>
              </div>
              <button class="btn primary" id="startBtn">Начать игру</button>
            </div>
            <div class="hint">Пропускать ответы можно — это не ошибка.</div>
          </div>
        </div>

        <div id="finalOverlay" class="overlay">
          <div class="card">
            <h2 id="finalTitle">
              <span class="icon" aria-hidden="true">
                <svg viewBox="0 0 24 24"><path d="M12 2l3 7h7l-5.5 4.2L18 21l-6-4-6 4 1.5-7.8L2 9h7z"/></svg>
              </span>
              —
            </h2>
            <p id="finalText">—</p>
            <div class="row" style="justify-content:flex-end;">
              <button class="btn primary" id="playAgainBtn">Играть ещё</button>
            </div>
          </div>
        </div>
      </div>
    </div>
  `;

  const scene = root.querySelector("#scene");
  const player = root.querySelector("#player");
  const playerImg = root.querySelector("#playerImg");
  const questionBox = root.querySelector("#questionBox");
  const scoreEl = root.querySelector("#score");
  const livesEl = root.querySelector("#lives");
  const feedback = root.querySelector("#feedback");
  const progressFill = root.querySelector("#progressFill");
  const progressText = root.querySelector("#progressText");

  const startOverlay = root.querySelector("#startOverlay");
  const startBtn = root.querySelector("#startBtn");
  const diffBtns = Array.from(root.querySelectorAll(".chipBtn"));

  const finalOverlay = root.querySelector("#finalOverlay");
  const finalTitle = root.querySelector("#finalTitle");
  const finalText = root.querySelector("#finalText");
  const playAgainBtn = root.querySelector("#playAgainBtn");

  const bgLayer = root.querySelector("#bgLayer");
  const loseTint = root.querySelector("#loseTint");

  const fxCanvas = root.querySelector("#fxCanvas");
  const fxCtx = fxCanvas ? fxCanvas.getContext("2d") : null;

  const dbg = root.querySelector("#cfgDebug");
  if(dbg){
    dbg.textContent = `CFG: playerSize=${CFG.playerSize} • answerSize=${CFG.answerSize} • textBg=${CFG.answerTextBgOn?"on":"off"} • img=${CFG.answerCardImg? "yes":"no"}`;
  }

  if(CFG.playerImg) playerImg.style.backgroundImage = `url('${cssUrl(CFG.playerImg)}')`;

  /* ===== confetti ===== */
  function resizeFx(){
    if(!fxCanvas) return;
    fxCanvas.width = Math.floor(root.clientWidth * devicePixelRatio);
    fxCanvas.height = Math.floor(root.clientHeight * devicePixelRatio);
    fxCanvas.style.width = root.clientWidth + "px";
    fxCanvas.style.height = root.clientHeight + "px";
    if(fxCtx) fxCtx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  window.addEventListener("resize", resizeFx);
  resizeFx();

  let confetti = [];
  let confettiUntil = 0;
  function startConfetti(ms=2600){
    if(!fxCtx || !CFG.winConfetti) return;
    resizeFx();
    confetti = [];
    const W = root.clientWidth, H = root.clientHeight;
    for(let i=0;i<160;i++){
      confetti.push({
        x: Math.random()*W,
        y: -20 - Math.random()*H*0.25,
        vx: -1.2 + Math.random()*2.4,
        vy: 2.4 + Math.random()*3.6,
        r: 2 + Math.random()*4,
        a: Math.random()*Math.PI*2,
        va: -0.25 + Math.random()*0.5,
        life: 900 + Math.random()*1600
      });
    }
    confettiUntil = performance.now() + ms;
  }
  function drawConfetti(now){
    if(!fxCtx) return;
    fxCtx.clearRect(0,0,root.clientWidth,root.clientHeight);
    if(now > confettiUntil) return;
    for(const p of confetti){
      p.x += p.vx; p.y += p.vy; p.a += p.va; p.vy += 0.02; p.life -= 16;
      if(p.y > root.clientHeight+40) { p.y = -20; p.x = Math.random()*root.clientWidth; p.vy = 2.4 + Math.random()*3.6; }
      fxCtx.save();
      fxCtx.translate(p.x, p.y);
      fxCtx.rotate(p.a);
      fxCtx.globalAlpha = Math.max(0, Math.min(1, p.life/900));
      fxCtx.fillRect(-p.r, -p.r*0.6, p.r*2, p.r*1.2);
      fxCtx.restore();
    }
  }

  /* ===== input keyboard + touch ===== */
  let keys = {};
  let touchActive = false;
  let touchTargetY = null;

  function sceneYFromClientY(clientY){
    const sr = scene.getBoundingClientRect();
    return clientY - sr.top;
  }

  scene.addEventListener("pointerdown", (e)=>{
    touchActive = true;
    touchTargetY = sceneYFromClientY(e.clientY);
    try{ scene.setPointerCapture(e.pointerId); }catch(_){}
  });
  scene.addEventListener("pointermove", (e)=>{
    if(!touchActive) return;
    touchTargetY = sceneYFromClientY(e.clientY);
  });
  function endTouch(){ touchActive = false; touchTargetY = null; }
  scene.addEventListener("pointerup", endTouch);
  scene.addEventListener("pointercancel", endTouch);
  scene.addEventListener("pointerleave", endTouch);
  window.addEventListener("touchmove", (e)=>{ e.preventDefault(); }, {passive:false});

  /* ===== audio ===== */
  let audioCtx = null, unlocked = false;
  function ensureAudio(){ if(audioCtx) return; const Ctx = window.AudioContext || window.webkitAudioContext; if(!Ctx) return; audioCtx = new Ctx(); }
  async function unlockAudio(){ ensureAudio(); if(!audioCtx) return; if(audioCtx.state==="suspended"){ try{await audioCtx.resume();}catch(e){} } unlocked = true; }
  function tone(freq, dur=0.16, type="sine", vol=0.28){
    if(!unlocked || !audioCtx) return;
    const now = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.setValueAtTime(freq, now);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.exponentialRampToValueAtTime(vol, now + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
    o.connect(g); g.connect(audioCtx.destination);
    o.start(now); o.stop(now + dur + 0.03);
  }
  function soundStart(){ tone(523.25,0.10,"sine"); setTimeout(()=>tone(659.25,0.10,"sine"),110); setTimeout(()=>tone(783.99,0.14,"sine"),230); }
  function soundOk(){ tone(660,0.10,"sine"); setTimeout(()=>tone(990,0.12,"sine"),90); }
  function soundBad(){ tone(220,0.14,"square"); setTimeout(()=>tone(180,0.16,"sawtooth"),90); }
  function soundWin(){ [523,659,784,988,784,988,1175].forEach((f,i)=>setTimeout(()=>tone(f,0.12,"sine"), i*120)); }
  function soundLose(){ [392,330,294,262].forEach((f,i)=>setTimeout(()=>tone(f,0.18,"triangle"), i*160)); }

  let state = null;
  let pendingTimer = null;

  function clearPending(){ if(pendingTimer!==null){ clearTimeout(pendingTimer); pendingTimer=null; } }
  function showOverlay(el, on){ if(on) el.classList.add("show"); else el.classList.remove("show"); }
  function preset(level){ return CFG.difficulty[level] || CFG.difficulty.easy; }

  function initState(){
    state = {
      phase:"меню", locked:true,
      score:0, lives:CFG.lives,
      remaining: CFG.questions.map((_,i)=>i),
      currentIdx:null, recent:[],
      active:[], lastSpawnAt:performance.now(), lastLaneY:null,
      difficulty:"easy",
      speed:preset("easy").speed,
      spawnEveryMs:preset("easy").spawnEveryMs,
      minXGap:preset("easy").minXGap,
      maxOnScreen:preset("easy").maxOnScreen,
      bgX: 0,
      tilt: 0,
    };
  }
  function applyDifficulty(level){
    const p = preset(level);
    state.difficulty = level;
    state.speed = p.speed;
    state.spawnEveryMs = p.spawnEveryMs;
    state.minXGap = p.minXGap;
    state.maxOnScreen = p.maxOnScreen;
    diffBtns.forEach(b=>b.classList.toggle("active", b.dataset.level===level));
  }
  function hearts(n){ return "❤️".repeat(Math.max(0,n)) + (n<=0 ? "—" : ""); }
  function updateProgress(){
    const total = CFG.questions.length;
    const done = total - state.remaining.length;
    const current = Math.min(done + 1, total);
    const pct = total ? Math.round((done / total) * 100) : 0;
    progressFill.style.width = pct + "%";
    progressText.textContent = `Вопрос ${current} из ${total}`;
  }
  function updateHUD(){
    scoreEl.textContent = String(state.score);
    livesEl.textContent = hearts(state.lives);
    const q = (state.currentIdx!==null) ? CFG.questions[state.currentIdx] : null;
    questionBox.textContent = q ? q.q : "";
    updateProgress();
  }
  function clearAnswers(){
    state.active.forEach(o=>o.el.remove());
    state.active = [];
    state.lastLaneY = null;
  }
  function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }
  function buildLanes(){
    const minY = 150;
    const maxY = scene.clientHeight - 100;
    const step = Math.max(84, Math.round(CFG.answerSize * 1.15));
    const lanes=[];
    for(let y=minY; y<=maxY; y+=step) lanes.push(y);
    return lanes.length ? lanes : [Math.round((minY+maxY)/2)];
  }
  function pickLaneY(){
    const lanes = buildLanes();
    let y = lanes[randInt(0, lanes.length-1)];
    if(state.lastLaneY!==null && lanes.length>1){
      let tries=0;
      while(y===state.lastLaneY && tries<10){
        y = lanes[randInt(0, lanes.length-1)];
        tries++;
      }
    }
    state.lastLaneY = y;
    return y;
  }

  function createOrb(answer){
    const el = document.createElement("div");
    el.className = "orb answer";
    el.dataset.correct = answer.correct ? "1" : "0";
    el.style.transform = "translate(-50%,-50%)";

    const layer = document.createElement("div");
    layer.className = "ansLayer";

    const txt = document.createElement("div");
    txt.className = "txt";
    txt.textContent = answer.text;

    layer.appendChild(txt);
    el.appendChild(layer);
    return el;
  }

  function rightEdgeX(){ return scene.clientWidth + 50; }
  function newestX(){
    let maxX = -Infinity;
    for(const o of state.active) maxX = Math.max(maxX, o.el.offsetLeft);
    return maxX;
  }

  function maybeSpawn(now){
    if(state.phase!=="игра" || state.locked) return;
    if(state.active.length >= state.maxOnScreen) return;
    if(now - state.lastSpawnAt < state.spawnEveryMs) return;

    const spawnX = rightEdgeX();
    const nx = newestX();
    if(nx!==-Infinity && nx > (spawnX - state.minXGap)) return;

    const q = (state.currentIdx!==null) ? CFG.questions[state.currentIdx] : null;
    if(!q) return;

    const pick = q.answers[randInt(0, q.answers.length-1)];
    const el = createOrb(pick);
    el.style.left = spawnX + "px";
    el.style.top = pickLaneY() + "px";

    scene.appendChild(el);
    state.active.push({ el, data: pick, hit:false });
    state.lastSpawnAt = now;
  }

  function showFeedback(text, ok){
    feedback.textContent = text;
    feedback.style.color = ok ? "#4cff9e" : "#ff6b6b";
    feedback.classList.add("show");
    setTimeout(()=>feedback.classList.remove("show"), 360);
  }
  function showPointsPop(x,y,points){
    const pop = document.createElement("div");
    pop.className = "pop";
    pop.textContent = `+${points}`;
    pop.style.left = x + "px";
    pop.style.top = y + "px";
    scene.appendChild(pop);
    setTimeout(()=>pop.remove(), 900);
  }

  function endGame(win){
    clearPending();
    state.phase="конец";
    state.locked=true;
    clearAnswers();
    updateHUD();
    win ? soundWin() : soundLose();

    if(win) startConfetti(2600);
    if(!win && loseTint){
      loseTint.classList.add("on");
      setTimeout(()=>loseTint.classList.remove("on"), 700);
    }

    // заголовок
    const textNode = finalTitle.childNodes[finalTitle.childNodes.length-1];
    if(textNode) textNode.textContent = win ? " Победа!" : " Конец игры";

    finalText.textContent = win ? `Ты ответил(а) на все вопросы! Очки: ${state.score}.`
                                : `Жизни закончились. Очки: ${state.score}.`;
    showOverlay(finalOverlay, true);
  }

  function pushRecent(idx){
    if(idx===null) return;
    state.recent.push(idx);
    const maxLen = Math.max(0, CFG.cooldownTurns + 1);
    while(state.recent.length > maxLen) state.recent.shift();
  }
  function pickNextQuestionWithCooldown(){
    if(!state.remaining.length) return null;
    if(state.remaining.length===1) return state.remaining[0];
    const banned = new Set(state.recent);
    const candidates = state.remaining.filter(i => !banned.has(i));
    let pool = candidates.length ? candidates : state.remaining.filter(i => i!==state.currentIdx);
    if(!pool.length) pool = state.remaining.slice();
    return pool[Math.floor(Math.random() * pool.length)];
  }
  function chooseNextQuestion(){
    pushRecent(state.currentIdx);
    state.currentIdx = pickNextQuestionWithCooldown();
    if(state.currentIdx===null){ endGame(true); return; }
    updateHUD();
    state.locked=false;
    clearAnswers();
    state.lastSpawnAt = performance.now();
  }

  function pulsePlayerOk(){
    player.classList.remove("okPulse");
    void player.offsetWidth;
    player.classList.add("okPulse");
    setTimeout(()=>player.classList.remove("okPulse"), 350);
  }

  function handleHit(correct, hitX, hitY){
    if(state.locked || state.phase!=="игра") return;
    state.locked = true;
    clearAnswers();
    clearPending();

    if(correct){
      state.score += CFG.pointsPerCorrect;
      showPointsPop(hitX, hitY, CFG.pointsPerCorrect);
      showFeedback(CFG.feedbackCorrect || "Верно!", true);
      soundOk();
      pulsePlayerOk();

      const idx = state.currentIdx;
      state.remaining = state.remaining.filter(x => x!==idx);

      pendingTimer = setTimeout(()=>{
        pendingTimer=null;
        state.remaining.length===0 ? endGame(true) : chooseNextQuestion();
      }, 420);
    }else{
      state.lives--;
      showFeedback(CFG.feedbackWrong || "Неверно!", false);
      soundBad();

      pendingTimer = setTimeout(()=>{
        pendingTimer=null;
        state.lives<=0 ? endGame(false) : chooseNextQuestion();
      }, 420);
    }
    updateHUD();
  }

  function checkCollision(obj){
    if(obj.hit || state.locked || state.phase!=="игра") return;
    const a = obj.el.getBoundingClientRect();
    const p = player.getBoundingClientRect();
    const overlap = !(a.right<p.left || a.left>p.right || a.bottom<p.top || a.top>p.bottom);
    if(!overlap) return;

    obj.hit = true;
    const sr = scene.getBoundingClientRect();
    const hitX = (a.left+a.right)/2 - sr.left;
    const hitY = (a.top+a.bottom)/2 - sr.top;

    const isCorrect = (obj.data.correct===true);

    if(isCorrect){
      obj.el.remove();
      handleHit(true, hitX, hitY);
    }else{
      obj.el.classList.add("blinkBad");
      setTimeout(()=>{
        if(obj.el && obj.el.isConnected) obj.el.remove();
        handleHit(false, hitX, hitY);
      }, 180);
    }
  }

  function resetGameForPlay(){
    clearPending();
    clearAnswers();
    state.score=0;
    state.lives=CFG.lives;
    state.remaining = CFG.questions.map((_,i)=>i);
    state.recent=[];
    state.phase="игра";
    state.locked=false;
    state.currentIdx = pickNextQuestionWithCooldown();
    state.lastSpawnAt = performance.now();
    player.style.top="50%";
    updateHUD();
  }

  async function startGame(){
    await unlockAudio();
    soundStart();
    showOverlay(startOverlay,false);
    showOverlay(finalOverlay,false);
    resetGameForPlay();
  }
  async function playAgain(){
    await unlockAudio();
    soundStart();
    showOverlay(finalOverlay,false);
    showOverlay(startOverlay,false);
    resetGameForPlay();
  }

  function loop(now){
    if(state.phase==="игра"){
      let y = player.offsetTop;

      // движение
      let dir = 0;
      if(!touchActive){
        if(keys.ArrowUp){ y -= CFG.playerSpeed; dir = -1; }
        if(keys.ArrowDown){ y += CFG.playerSpeed; dir = +1; }
      }else{
        if(touchTargetY !== null){
          const target = touchTargetY - player.clientHeight/2;
          const diff = target - y;
          const step = Math.sign(diff) * Math.min(Math.abs(diff), CFG.playerSpeed * 1.6);
          y += step;
          if(Math.abs(diff) > 1) dir = (diff > 0) ? +1 : -1;
        }
      }

      y = Math.max(0, Math.min(scene.clientHeight - player.clientHeight, y));
      player.style.top = y + "px";

      // наклон игрока
      const tiltMax = clampNum(CFG.playerTiltMax, 0, 35, 18);
      const targetTilt = dir * tiltMax;
      const smooth = clampNum(CFG.playerTiltSmooth, 0.01, 0.6, 0.22);
      state.tilt = state.tilt + (targetTilt - state.tilt) * smooth;
      if(dir === 0) state.tilt *= 0.88;
      player.style.setProperty("--tilt", state.tilt.toFixed(2) + "deg");

      // бесшовный фон (repeat-x)
      if(bgLayer && !CFG.transparentBg && CFG.bgImg){
        const factor = clampNum(CFG.bgScrollFactor, 0, 3, 0.35);
        state.bgX = (state.bgX - state.speed * factor);

        const sceneH = Math.max(1, scene.clientHeight);
        const t = (y / sceneH) - 0.5;
        const parY = clampNum(CFG.bgParallaxY, 0, 80, 18);
        const bgY = (-t) * parY;

        bgLayer.style.backgroundPosition = `${state.bgX.toFixed(2)}px calc(50% + ${bgY.toFixed(2)}px)`;
      }

      maybeSpawn(now);

      if(!state.locked){
        const leftLimit = -160;
        const next=[];
        for(const obj of state.active){
          obj.el.style.left = (obj.el.offsetLeft - state.speed) + "px";
          checkCollision(obj);
          if(obj.el.isConnected){
            if(obj.el.offsetLeft >= leftLimit) next.push(obj);
            else obj.el.remove();
          }
        }
        state.active = next;
      }
    }

    drawConfetti(now);
    requestAnimationFrame(loop);
  }

  diffBtns.forEach(btn=>{
    btn.addEventListener("click", async ()=>{
      await unlockAudio();
      applyDifficulty(btn.dataset.level);
    });
  });
  startBtn.addEventListener("click", startGame);
  playAgainBtn.addEventListener("click", playAgain);

  window.addEventListener("keydown", async (e)=>{ keys[e.key]=true; await unlockAudio(); });
  window.addEventListener("keyup",(e)=>{ keys[e.key]=false; });
  window.addEventListener("pointerdown", async ()=>{ await unlockAudio(); }, {passive:true});

  initState();
  applyDifficulty("easy");
  updateHUD();
  player.style.top="50%";
  showOverlay(startOverlay,true);
  showOverlay(finalOverlay,false);
  loop(performance.now());
}
</script>
</body>
</html>
