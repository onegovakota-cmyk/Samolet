<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Catch the Answer</title>
  <link rel="icon" href="data:,">

  <style>
    :root{
      --bg: transparent;

      --panel-bg: rgba(10,10,20,.60);
      --panel-brd: rgba(255,255,255,.18);
      --shadow: 0 16px 60px rgba(0,0,0,.42);

      /* –æ—Ç–≤–µ—Ç—ã —Ç—ë–º–Ω—ã–µ => —Ç–µ–∫—Å—Ç –≤–∏–¥–µ–Ω –Ω–∞ –±–µ–ª–æ–º —Ñ–æ–Ω–µ */
      --answer-bg: rgba(20, 18, 34, .82);
      --answer-brd: rgba(255,255,255,.22);
      --answer-text: rgba(255,255,255,.98);

      --player-bg: rgba(120,90,255,.22);
      --player-brd: rgba(120,90,255,.40);

      --good: #4cff9e;
      --bad:  #ff6b6b;

      --neon-yellow: #ffd84a;

      --size: 86px;
    }

    html,body{margin:0;height:100%;background:var(--bg)!important;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;overflow:hidden;}
    #game{position:relative;width:100%;height:100%;}

    /* HUD */
    #hud{
      position:absolute; top:12px; left:12px; right:12px;
      display:flex; align-items:flex-start; justify-content:space-between;
      gap:12px; z-index:60; pointer-events:none;
    }
    .pill{
      background: var(--panel-bg);
      border: 1px solid var(--panel-brd);
      border-radius: 999px;
      padding: 10px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display:flex; gap:10px; align-items:center;
      white-space:nowrap;
      color: rgba(255,255,255,.92);
    }
    .pill .label{font-size:12px;color:rgba(255,255,255,.72);font-weight:900}
    .pill .value{font-size:16px;font-weight:1100}

    /* QUESTION */
    #questionWrap{
      position:absolute; top:12px; left:50%; transform:translateX(-50%);
      z-index:61; pointer-events:none;
      max-width:min(900px, calc(100% - 24px));
    }
    #questionBox{
      background: var(--panel-bg);
      border: 1px solid var(--panel-brd);
      border-radius: 999px;
      padding: 12px 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      text-align:center;
      font-weight:1100;
      font-size:14px;
      color: rgba(255,255,255,.92);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }

    /* SCENE */
    #scene{position:absolute; inset:0; overflow:hidden;}

    .orb{
      position:absolute;
      width: var(--size);
      height: var(--size);
      border-radius: 50%;
      display:flex; align-items:center; justify-content:center;
      user-select:none;
    }

    #player{
      left:92px; top:50%;
      transform:translate(-50%,-50%);
      background: var(--player-bg);
      border: 1px solid var(--player-brd);
      box-shadow: 0 12px 40px rgba(0,0,0,.28), 0 0 26px rgba(120,90,255,.25);
    }
    #player:before{
      content:"";
      width:18px;height:18px;border-radius:999px;
      background: rgba(255,255,255,.88);
      box-shadow:0 0 14px rgba(255,255,255,.25);
    }

    /* ANSWERS */
    .answer{
      background: var(--answer-bg);
      border: 1px solid var(--answer-brd);
      box-shadow: 0 16px 55px rgba(0,0,0,.35);
      color: var(--answer-text);
      padding: 10px 10px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      gap:6px;
    }
    .answer .lab{
      font-weight:1200;
      font-size:18px;
      line-height:1;
      letter-spacing:.8px;
      opacity:.98;
      text-shadow: 0 10px 22px rgba(0,0,0,.55);
      -webkit-text-stroke: 0.35px rgba(0,0,0,.35);
    }
    .answer .txt{
      font-weight:1100;
      font-size:13px;
      line-height:1.12;
      opacity:1;
      max-width: 180px;
      white-space:normal;
      word-break:break-word;

      padding: 4px 8px;
      border-radius: 10px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);

      text-shadow: 0 10px 22px rgba(0,0,0,.55);
      -webkit-text-stroke: 0.35px rgba(0,0,0,.35);
    }

    /* +points neon yellow */
    .pop{
      position:absolute;
      font-weight:1300;
      font-size:20px;
      pointer-events:none;
      transform:translate(-50%,-50%);
      color: var(--neon-yellow);
      text-shadow:
        0 0 10px rgba(255,216,74,.90),
        0 0 24px rgba(255,216,74,.70),
        0 16px 36px rgba(0,0,0,.55);
      animation: popUp .78s ease-out forwards;
      z-index:80;
    }
    @keyframes popUp{
      0%{opacity:0;transform:translate(-50%,-50%) scale(.9);}
      15%{opacity:1;transform:translate(-50%,-62%) scale(1.05);}
      100%{opacity:0;transform:translate(-50%,-112%) scale(1);}
    }

    #feedback{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      font-size:30px; font-weight:1200;
      pointer-events:none;
      opacity:0; transition:.18s;
      z-index:70;
      text-shadow: 0 16px 36px rgba(0,0,0,.55);
      color: rgba(255,255,255,.92);
    }
    #feedback.show{opacity:1;}

    /* progress bottom */
    #progressWrap{
      position:absolute; left:12px; right:12px; bottom:12px;
      z-index:90; pointer-events:none;
    }
    #progressBar{
      height: 20px;
      border-radius: 999px;
      background: rgba(0,0,0,.14);
      border: 1px solid rgba(255,255,255,.22);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #progressFill{
      height:100%;
      width:0%;
      background: rgba(120,90,255,.72);
      border-radius:999px;
      transition: width .25s ease;
    }
    #progressText{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      font-size:12px; font-weight:1200;
      color: rgba(255,255,255,.96);
      text-shadow:0 10px 22px rgba(0,0,0,.5);
    }

    #final{
      position:absolute; inset:0;
      background: rgba(0,0,0,.78);
      display:none;
      align-items:center; justify-content:center;
      flex-direction:column; gap:14px;
      z-index:120; text-align:center; padding:20px;
      color: rgba(255,255,255,.92);
    }
    #final.show{display:flex;}
    #final h1{margin:0;font-size:30px;}
    #final .small{opacity:.85;max-width:560px;line-height:1.4;font-size:13px;}
    #final button{
      pointer-events:auto;
      padding:10px 16px;border-radius:14px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.10);
      color:rgba(255,255,255,.92);
      font-weight:1100;cursor:pointer;
    }

    #version{
      position:absolute; right:12px; bottom:40px;
      font-size:12px; opacity:.55; pointer-events:none; z-index:200;
      color: rgba(0,0,0,.35);
    }
  </style>
</head>

<body>
<div id="game">
  <div id="hud">
    <div class="pill"><div class="label">–û—á–∫–∏</div><div class="value" id="score">0</div></div>
    <div class="pill" id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
  </div>

  <div id="questionWrap"><div id="questionBox">‚Äî</div></div>

  <div id="scene">
    <div class="orb" id="player"></div>
  </div>

  <div id="feedback"></div>

  <div id="progressWrap">
    <div id="progressBar">
      <div id="progressFill"></div>
      <div id="progressText">–í–æ–ø—Ä–æ—Å 1 –∏–∑ 1</div>
    </div>
  </div>

  <div id="final">
    <h1 id="finalTitle">‚Äî</h1>
    <div class="small" id="finalText"></div>
    <button onclick="restart()">–ò–≥—Ä–∞—Ç—å –µ—â—ë</button>
  </div>

  <div id="version">v10</div>
</div>

<script>
/* ============ CONFIG ============ */
const GAME_CONFIG = {
  lives: 3,
  speed: 3.2,
  playerSpeed: 7,
  feedbackMs: 420,

  scoring: { pointsPerCorrect: 10, popText: (pts)=>`+${pts}` },

  sound: { enabled:true, ok:{volume:0.25}, bad:{volume:0.30} },

  layout: {
    paddingTop: 96,
    paddingBottom: 86,
    laneMinDist: 92,
  },

  // –ü–æ—Ç–æ–∫: –∫–∞–∫ —á–∞—Å—Ç–æ —Å–ø–∞–≤–Ω–∏—Ç—å –Ω–æ–≤—ã–π –æ–±—ä–µ–∫—Ç (–º–µ–Ω—å—à–µ = –ø–ª–æ—Ç–Ω–µ–µ)
  spawn: {
    everyMs: 520,
    jitterMs: 220,     // –Ω–µ–±–æ–ª—å—à–∞—è —Å–ª—É—á–∞–π–Ω–æ—Å—Ç—å
    startXPad: 50,     // –∑–∞ –ø—Ä–∞–≤—ã–º –∫—Ä–∞–µ–º
    minXGap: 22,       // –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∑–∞–∑–æ—Ä –ø–æ X –º–µ–∂–¥—É –Ω–æ–≤—ã–º–∏ –æ–±—ä–µ–∫—Ç–∞–º–∏
  },

  questions: [
    { q:"–°—Ç–æ–ª–∏—Ü–∞ –§—Ä–∞–Ω—Ü–∏–∏?", answers:[
      {label:"A", text:"–ü–∞—Ä–∏–∂",  correct:true},
      {label:"B", text:"–†–∏–º",    correct:false},
      {label:"C", text:"–ë–µ—Ä–ª–∏–Ω", correct:false},
    ]},
    { q:"2 + 2 = ?", answers:[
      {label:"A", text:"3", correct:false},
      {label:"B", text:"4", correct:true},
      {label:"C", text:"5", correct:false},
    ]},
    { q:"–ì–¥–µ –±–æ–ª—å—à–µ: 7 –∏–ª–∏ 9?", answers:[
      {label:"A", text:"7", correct:false},
      {label:"B", text:"9", correct:true},
      {label:"C", text:"—Ä–∞–≤–Ω—ã", correct:false},
    ]},
  ],
};
/* =============================== */

const scene = document.getElementById("scene");
const player = document.getElementById("player");
const questionBox = document.getElementById("questionBox");
const scoreEl = document.getElementById("score");
const livesEl = document.getElementById("lives");
const feedback = document.getElementById("feedback");
const progressFill = document.getElementById("progressFill");
const progressText = document.getElementById("progressText");
const final = document.getElementById("final");
const finalTitle = document.getElementById("finalTitle");
const finalText = document.getElementById("finalText");

let keys = {};
let raf = null;
let state = null;

/* WebAudio */
let audioCtx = null, audioUnlocked = false;
function ensureAudio(){
  if(!GAME_CONFIG.sound.enabled) return;
  if(audioCtx) return;
  const Ctx = window.AudioContext || window.webkitAudioContext;
  if(!Ctx) return;
  audioCtx = new Ctx();
}
async function unlockAudio(){
  if(!GAME_CONFIG.sound.enabled) return;
  ensureAudio();
  if(!audioCtx) return;
  if(audioCtx.state === "suspended") { try{ await audioCtx.resume(); }catch(e){} }
  audioUnlocked = true;
}
function beepOk(){
  if(!GAME_CONFIG.sound.enabled || !audioUnlocked || !audioCtx) return;
  const v = GAME_CONFIG.sound.ok.volume ?? 0.25;
  const now = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type="sine";
  o.frequency.setValueAtTime(660, now);
  o.frequency.exponentialRampToValueAtTime(990, now+0.12);
  g.gain.setValueAtTime(0.0001, now);
  g.gain.exponentialRampToValueAtTime(v, now+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, now+0.18);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(now); o.stop(now+0.2);
}
function beepBad(){
  if(!GAME_CONFIG.sound.enabled || !audioUnlocked || !audioCtx) return;
  const v = GAME_CONFIG.sound.bad.volume ?? 0.30;
  const now = audioCtx.currentTime;
  const o1 = audioCtx.createOscillator();
  const o2 = audioCtx.createOscillator();
  const g  = audioCtx.createGain();
  o1.type="square"; o2.type="sawtooth";
  o1.frequency.setValueAtTime(220, now);
  o2.frequency.setValueAtTime(170, now);
  g.gain.setValueAtTime(0.0001, now);
  g.gain.exponentialRampToValueAtTime(v, now+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, now+0.22);
  o1.connect(g); o2.connect(g); g.connect(audioCtx.destination);
  o1.start(now); o2.start(now);
  o1.stop(now+0.24); o2.stop(now+0.24);
}

function initState(){
  state = {
    qIndex: 0,
    lives: GAME_CONFIG.lives,
    score: 0,
    locked: false,
    active: [],
    running: true,
    lastSpawnAt: performance.now(),
    lastSpawnX: null,
  };
}

function hearts(n){ return "‚ù§Ô∏è".repeat(Math.max(0,n)) + (n<=0 ? "‚Äî" : ""); }

function updateProgress(){
  const total = GAME_CONFIG.questions.length;
  const current = Math.min(state.qIndex + 1, total);
  const pct = total ? Math.round(((current-1) / total) * 100) : 0;
  progressFill.style.width = pct + "%";
  progressText.textContent = `–í–æ–ø—Ä–æ—Å ${current} –∏–∑ ${total}`;
}

function updateHUD(){
  scoreEl.textContent = String(state.score);
  livesEl.textContent = hearts(state.lives);
  questionBox.textContent = state.qIndex < GAME_CONFIG.questions.length ? GAME_CONFIG.questions[state.qIndex].q : "";
  updateProgress();
}

function clearAnswers(){
  state.active.forEach(o=>o.el.remove());
  state.active = [];
  state.lastSpawnX = null;
}

function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }
function pickLaneY(){
  // —Å–æ–∑–¥–∞—ë–º "—É—Ä–æ–≤–Ω–∏" –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏, —á—Ç–æ–±—ã –≤–∞—Ä–∏–∞–Ω—Ç—ã –±—ã–ª–∏ –Ω–∞ —Ä–∞–∑–Ω—ã—Ö –º–µ—Å—Ç–∞—Ö
  const minY = GAME_CONFIG.layout.paddingTop;
  const maxY = scene.clientHeight - GAME_CONFIG.layout.paddingBottom;
  const step = GAME_CONFIG.layout.laneMinDist;
  const lanes = [];
  for(let y=minY; y<=maxY; y+=step) lanes.push(y);
  if(!lanes.length) return Math.round((minY+maxY)/2);
  return lanes[randInt(0, lanes.length-1)];
}

function createAnswerOrb(answer){
  const el = document.createElement("div");
  el.className = "orb answer";
  el.dataset.correct = answer.correct ? "1":"0";

  const lab = document.createElement("div");
  lab.className = "lab";
  lab.textContent = answer.label;

  const txt = document.createElement("div");
  txt.className = "txt";
  txt.textContent = answer.text;

  el.appendChild(lab);
  el.appendChild(txt);
  return el;
}

function maybeSpawnStream(now){
  if(state.locked) return;

  const base = GAME_CONFIG.spawn.everyMs;
  const jitter = GAME_CONFIG.spawn.jitterMs;
  const due = state.lastSpawnAt + base + (Math.random()*jitter - jitter/2);

  if(now < due) return;

  // –Ω–µ –¥–µ–ª–∞–µ–º —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π –∑–∞–∑–æ—Ä –ø–æ X: –µ—Å–ª–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–π –æ–±—ä–µ–∫—Ç –µ—â—ë –±–ª–∏–∑–∫–æ —Å–ø—Ä–∞–≤–∞, –ø–æ–¥–æ–∂–¥—ë–º —á—É—Ç—å
  const rightEdge = scene.clientWidth + GAME_CONFIG.spawn.startXPad;
  const minGap = GAME_CONFIG.spawn.minXGap;

  // –≤—ã—á–∏—Å–ª–∏–º —Ç–µ–∫—É—â–∏–π —Å–∞–º—ã–π "–ø—Ä–∞–≤—ã–π" –æ–±—ä–µ–∫—Ç
  let currentMaxX = -Infinity;
  for(const o of state.active){
    const x = o.el.offsetLeft;
    if(x > currentMaxX) currentMaxX = x;
  }
  if(currentMaxX !== -Infinity && currentMaxX > rightEdge - minGap){
    // —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ ‚Äî –ø–æ–¥–æ–∂–¥—ë–º –Ω–µ–º–Ω–æ–≥–æ
    state.lastSpawnAt = now - base/2;
    return;
  }

  const q = GAME_CONFIG.questions[state.qIndex];
  const pick = q.answers[randInt(0, q.answers.length-1)]; // ‚úÖ –º–æ–∂–Ω–æ –º–Ω–æ–≥–æ –æ–¥–∏–Ω–∞–∫–æ–≤—ã—Ö
  const el = createAnswerOrb(pick);

  el.style.left = rightEdge + "px";
  el.style.top = pickLaneY() + "px";
  el.style.transform = "translate(-50%,-50%)";

  scene.appendChild(el);
  state.active.push({ el, data: pick, hit:false });

  state.lastSpawnAt = now;
}

function showFeedback(text, ok){
  feedback.textContent = text;
  feedback.style.color = ok ? "var(--good)" : "var(--bad)";
  feedback.classList.add("show");
  setTimeout(()=>feedback.classList.remove("show"), Math.max(120, GAME_CONFIG.feedbackMs - 80));
}

function showPointsPop(x,y,points){
  const pop = document.createElement("div");
  pop.className = "pop";
  pop.textContent = GAME_CONFIG.scoring.popText(points);
  pop.style.left = x + "px";
  pop.style.top = y + "px";
  scene.appendChild(pop);
  setTimeout(()=>pop.remove(), 900);
}

function endGame(win){
  state.locked = true;
  state.running = false;
  clearAnswers();
  updateHUD();
  final.classList.add("show");
  finalTitle.textContent = win ? "üéâ –û—Ç–ª–∏—á–Ω–æ!" : "üíÄ –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞";
  const total = GAME_CONFIG.questions.length;
  const answered = Math.min(state.qIndex, total);
  finalText.textContent = `–ü—Ä–æ–π–¥–µ–Ω–æ ${answered}/${total}. –û—á–∫–∏: ${state.score}.`;
  if(raf) cancelAnimationFrame(raf);
  raf = null;
}

function goNextQuestion(){
  state.qIndex++;
  state.locked = false;

  if(state.lives <= 0){ endGame(false); return; }
  if(state.qIndex >= GAME_CONFIG.questions.length){ endGame(true); return; }

  updateHUD();
  clearAnswers();                 // –æ—á–∏—â–∞–µ–º –ø–æ—Ç–æ–∫ –ø–æ–¥ —Å–ª–µ–¥—É—é—â–∏–π –≤–æ–ø—Ä–æ—Å
  state.lastSpawnAt = performance.now();
}

function handleHit(correct, hitX, hitY){
  if(state.locked) return;
  state.locked = true;

  // –ø—Ä–∏ –ø–æ–ø–∞–¥–∞–Ω–∏–∏ –æ—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏ —á–∏—Å—Ç–∏–º –ø–æ—Ç–æ–∫
  clearAnswers();

  if(correct){
    const pts = GAME_CONFIG.scoring.pointsPerCorrect;
    state.score += pts;
    updateHUD();
    showPointsPop(hitX, hitY, pts);
    showFeedback("–í–µ—Ä–Ω–æ", true);
    beepOk();
  } else {
    state.lives--;
    updateHUD();
    showFeedback("–ù–µ–≤–µ—Ä–Ω–æ", false);
    beepBad();
    player.animate(
      [{transform:"translate(-50%,-50%)"},
       {transform:"translate(-50%,-50%) translateX(-4px)"},
       {transform:"translate(-50%,-50%) translateX(4px)"},
       {transform:"translate(-50%,-50%)"}],
      {duration:220}
    );
  }

  setTimeout(goNextQuestion, GAME_CONFIG.feedbackMs);
}

function checkCollision(obj){
  if(obj.hit || state.locked) return;
  const a = obj.el.getBoundingClientRect();
  const p = player.getBoundingClientRect();
  const overlap = !(a.right<p.left || a.left>p.right || a.bottom<p.top || a.top>p.bottom);
  if(overlap){
    obj.hit = true;
    const sr = scene.getBoundingClientRect();
    const hitX = (a.left+a.right)/2 - sr.left;
    const hitY = (a.top+a.bottom)/2 - sr.top;
    obj.el.remove();
    handleHit(obj.data.correct===true, hitX, hitY);
  }
}

function loop(now){
  if(!state || !state.running) return;

  // player
  let y = player.offsetTop;
  if(keys.ArrowUp) y -= GAME_CONFIG.playerSpeed;
  if(keys.ArrowDown) y += GAME_CONFIG.playerSpeed;
  y = Math.max(0, Math.min(scene.clientHeight - player.clientHeight, y));
  player.style.top = y + "px";

  // stream spawn
  maybeSpawnStream(now);

  // move answers + remove missed (‚úÖ –ø—Ä–æ–ø—É—Å–∫ –ù–ï –æ—à–∏–±–∫–∞)
  if(!state.locked){
    const leftLimit = -140;
    const next = [];
    for(const obj of state.active){
      const x = obj.el.offsetLeft - GAME_CONFIG.speed;
      obj.el.style.left = x + "px";
      checkCollision(obj);

      if(obj.el.isConnected){
        if(obj.el.offsetLeft >= leftLimit) next.push(obj);
        else obj.el.remove();
      }
    }
    state.active = next;
  }

  raf = requestAnimationFrame(loop);
}

function restart(){
  final.classList.remove("show");
  if(raf) cancelAnimationFrame(raf);
  raf = null;

  initState();
  updateHUD();
  player.style.top = "50%";
  clearAnswers();
  state.lastSpawnAt = performance.now();
  state.running = true;
  loop(performance.now());
}

window.addEventListener("keydown", async (e)=>{
  keys[e.key]=true;
  if(!audioUnlocked) await unlockAudio();
});
window.addEventListener("keyup",(e)=>keys[e.key]=false);
window.addEventListener("pointerdown", async ()=>{ if(!audioUnlocked) await unlockAudio(); }, {passive:true });

initState();
updateHUD();
player.style.top = "50%";
state.lastSpawnAt = performance.now();
loop(performance.now());
</script>
</body>
</html>
