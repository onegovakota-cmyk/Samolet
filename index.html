<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>–ò–≥—Ä–∞ + –†–µ–¥–∞–∫—Ç–æ—Ä (Genially, one-file)</title>
  <link rel="icon" href="data:,">
  <style>
    :root{
      --ui-card: rgba(18,16,32,.78);
      --ui-border: rgba(255,255,255,.14);
      --ui-text: rgba(255,255,255,.92);
      --ui-sub: rgba(255,255,255,.68);
      --shadow: 0 18px 65px rgba(0,0,0,.45);
      --accent: rgba(120,90,255,.55);
      --accent-border: rgba(120,90,255,.65);
    }
    html,body{margin:0;height:100%;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:transparent;}
    body{overflow:hidden;}

    /* ===== EDITOR ===== */
    #editorApp{
      height:100%;
      display:flex;
      gap:12px;
      padding:12px;
      box-sizing:border-box;
      background: radial-gradient(1200px 600px at 20% 10%, rgba(120,90,255,.18), transparent 60%),
                  radial-gradient(900px 500px at 85% 20%, rgba(76,255,158,.08), transparent 55%),
                  rgba(10,10,16,.98);
      color:var(--ui-text);
    }
    .panel{
      background: var(--ui-card);
      border:1px solid var(--ui-border);
      border-radius:16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #left{width:min(860px, 66vw);min-width:420px;display:flex;flex-direction:column;overflow:hidden;}
    #right{flex:1;display:flex;flex-direction:column;overflow:hidden;}
    .head{
      padding:14px 14px 10px;
      border-bottom:1px solid rgba(255,255,255,.10);
      display:flex;align-items:flex-start;justify-content:space-between;gap:10px;
    }
    .head h1{margin:0;font-size:16px;font-weight:900;letter-spacing:.2px;}
    .head .sub{margin-top:4px;font-size:12px;color:var(--ui-sub);line-height:1.35;}
    .content{padding:12px 14px 14px;overflow:auto;}
    .section{
      border:1px solid rgba(255,255,255,.10);
      border-radius:14px;
      padding:12px;
      margin:10px 0;
      background: rgba(255,255,255,.04);
    }
    .section h3{margin:0 0 10px;font-size:13px;font-weight:900;color:rgba(255,255,255,.90);}
    .grid{display:grid;grid-template-columns: 1fr 1fr;gap:10px;}
    label{display:block;font-size:12px;color:var(--ui-sub);margin-bottom:6px;}
    input[type="text"], input[type="number"], select, textarea{
      width:100%;box-sizing:border-box;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.95);
      border-radius:12px;padding:10px 10px;outline:none;font-size:13px;
    }
    textarea{min-height:100px; resize:vertical; line-height:1.35;}
    input[type="color"]{
      width:100%;height:42px;border-radius:12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      padding:6px;box-sizing:border-box;
    }
    input[type="range"]{width:100%;}
    .rangeRow{display:grid;grid-template-columns: 1fr 86px;gap:10px;align-items:center;}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;}
    .btn{
      appearance:none;border:1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.10);
      color: rgba(255,255,255,.95);
      padding:10px 12px;border-radius:12px;
      font-weight:800;font-size:13px;cursor:pointer;user-select:none;white-space:nowrap;
    }
    .btn.primary{background: var(--accent);border-color: var(--accent-border);}
    .btn.danger{background: rgba(255,107,107,.25);border-color: rgba(255,107,107,.45);}
    .hint{font-size:12px;color: var(--ui-sub);line-height:1.35;margin-top:6px;}
    .hr{height:1px;background:rgba(255,255,255,.10);margin:10px 0;}
    .badge{
      font-size:11px;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);color: rgba(255,255,255,.85);white-space:nowrap;
    }

    .qitem{border:1px solid rgba(255,255,255,.10);border-radius:14px;padding:10px;background: rgba(0,0,0,.12);margin-bottom:10px;}
    .qtop{display:flex;gap:8px;align-items:center;justify-content:space-between;margin-bottom:8px;}
    .qtop strong{font-size:12px;}
    .answers{display:flex;flex-direction:column;gap:8px;}
    .ansRow{display:grid;grid-template-columns: 1fr 84px;gap:8px;align-items:center;}
    .chk{display:flex;gap:8px;align-items:center;font-size:12px;color: rgba(255,255,255,.85);}
    .chk input{width:18px;height:18px;}
    .miniBtn{padding:8px 10px;border-radius:10px;font-size:12px;}

    #previewWrap{flex:1;display:flex;flex-direction:column;overflow:hidden;}
    #previewFrame{width:100%;flex:1;border:0;background:transparent;}

    #codeBox{
      width:100%;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.20);
      color: rgba(255,255,255,.95);
      padding:12px;
      box-sizing:border-box;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:12px;
      line-height:1.35;
      outline:none;
      resize:vertical;
      min-height:110px;
    }

    .checkItem{
      display:flex;align-items:center;gap:10px;
      padding:10px 10px;border-radius:12px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.12);
      font-size:13px;color:rgba(255,255,255,.92);
    }
    .checkItem input{width:18px;height:18px;}

    .sideBySide{display:grid;grid-template-columns: 1fr 260px;gap:12px;align-items:start;}
    .previewCard{
      width:260px;height:260px;border-radius:16px;border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.18);display:flex;align-items:center;justify-content:center;
      position:relative;overflow:hidden;
    }
    .previewCaption{
      position:absolute; left:10px; top:10px;font-size:11px;padding:6px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.14);background: rgba(0,0,0,.25);color: rgba(255,255,255,.85);
      backdrop-filter: blur(6px);-webkit-backdrop-filter: blur(6px);
    }

    /* ===== GAME ROOT ===== */
    #gameRoot{position:relative;width:100%;height:100%;overflow:hidden;background:transparent;}
  </style>
</head>

<body>
<div id="editorApp" style="display:none;">
  <div id="left" class="panel">
    <div class="head">
      <div>
        <h1>–†–µ–¥–∞–∫—Ç–æ—Ä –∏–≥—Ä—ã (Genially)</h1>
        <div class="sub">–ê–≤—Ç–æ-–ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä ‚Ä¢ —Å–µ–Ω—Å–æ—Ä ‚Ä¢ –ø–∞—Ä–µ–Ω–∏–µ/–Ω–∞–∫–ª–æ–Ω ‚Ä¢ –±–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ñ–æ–Ω ‚Ä¢ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä—ã –∏–≥—Ä–æ–∫–∞ –∏ –æ—Ç–≤–µ—Ç–∞ —Å–ø—Ä–∞–≤–∞</div>
      </div>
      <div class="badge" id="cfgSizeBadge">cfg: ‚Äî</div>
    </div>

    <div class="content">
      <div class="section">
        <h3>–°—Å—ã–ª–∫–∞ –ø—Ä–æ–µ–∫—Ç–∞ (–¥–ª—è iframe)</h3>
        <label>Base URL (–ø–æ–ª–Ω—ã–π –ø—É—Ç—å –∫ —ç—Ç–æ–º—É .html)</label>
        <input id="baseUrl" type="text" placeholder="https://username.github.io/repo/–∏–≥—Ä–∞.html" />
        <div class="hint">–î–ª—è –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —Å–ø—Ä–∞–≤–∞ baseUrl –Ω–µ –Ω—É–∂–µ–Ω ‚Äî –æ–Ω –≤—Å–µ–≥–¥–∞ –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç —ç—Ç–æ—Ç –∂–µ —Ñ–∞–π–ª.</div>
      </div>

      <div class="section">
        <h3>–¢–µ–∫—Å—Ç –∏ —à—Ä–∏—Ñ—Ç—ã</h3>
        <div class="grid">
          <div>
            <label>–®—Ä–∏—Ñ—Ç</label>
            <select id="fontFamily">
              <option value="system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif">–°–∏—Å—Ç–µ–º–Ω—ã–π</option>
              <option value="'Arial', sans-serif">Arial</option>
              <option value="'Trebuchet MS', sans-serif">Trebuchet</option>
              <option value="'Verdana', sans-serif">Verdana</option>
            </select>
          </div>
          <div>
            <label>–ù–∞—Å—ã—â–µ–Ω–Ω–æ—Å—Ç—å</label>
            <select id="fontWeight">
              <option value="900">–û—á–µ–Ω—å –∂–∏—Ä–Ω—ã–π</option>
              <option value="700">–ñ–∏—Ä–Ω—ã–π</option>
              <option value="600">–ü–æ–ª—É–∂–∏—Ä–Ω—ã–π</option>
              <option value="500">–û–±—ã—á–Ω—ã–π</option>
            </select>
          </div>
        </div>

        <div class="hr"></div>

        <div class="grid">
          <div><label>–†–∞–∑–º–µ—Ä –≤–æ–ø—Ä–æ—Å–∞ (px)</label><input id="questionSize" type="number" min="12" max="70" value="24" /></div>
          <div><label>–¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ –≤–æ–ø—Ä–æ—Å–∞</label><input id="questionColor" type="color" value="#ffffff" /></div>

          <div><label>–¶–≤–µ—Ç —Ñ–æ–Ω–∞ –≤–æ–ø—Ä–æ—Å–∞</label><input id="questionBgColor" type="color" value="#0a0a14" /></div>
          <div><label>–¶–≤–µ—Ç —Ä–∞–º–∫–∏ –≤–æ–ø—Ä–æ—Å–∞</label><input id="questionBorderColor" type="color" value="#ffffff" /></div>

          <div><label>–†–∞–∑–º–µ—Ä –æ—á–∫–æ–≤ (px)</label><input id="scoreSize" type="number" min="12" max="70" value="24" /></div>
          <div><label>–†–∞–∑–º–µ—Ä –∂–∏–∑–Ω–µ–π (px)</label><input id="livesSize" type="number" min="12" max="70" value="24" /></div>

          <div><label>HUD: —Ü–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞</label><input id="hudTextColor" type="color" value="#ffffff" /></div>
          <div><label>HUD: —Ü–≤–µ—Ç –ø–æ–¥–ª–æ–∂–∫–∏</label><input id="hudPanelColor" type="color" value="#0f0f19" /></div>
        </div>
      </div>

      <div class="section">
        <h3>–¶–≤–µ—Ç–∞ UI</h3>
        <div class="grid">
          <div><label>–¶–≤–µ—Ç –∏–∫–æ–Ω–æ–∫ (—Å—Ç–∞—Ä—Ç/—Ñ–∏–Ω–∏—à)</label><input id="iconColor" type="color" value="#7a5aff" /></div>
          <div><label>–¶–≤–µ—Ç –∫–Ω–æ–ø–æ–∫</label><input id="btnColor" type="color" value="#7a5aff" /></div>
          <div><label>–¶–≤–µ—Ç —Ç–µ–∫—Å—Ç–∞ –Ω–∞ –∫–Ω–æ–ø–∫–∞—Ö</label><input id="btnTextColor" type="color" value="#ffffff" /></div>
          <div><label>–¶–≤–µ—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å–∞</label><input id="progressColor" type="color" value="#7a5aff" /></div>
          <div><label>–í—ã—Å–æ—Ç–∞ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ (px)</label><input id="progressHeight" type="number" min="14" max="70" value="30" /></div>
        </div>
      </div>

      <div class="section">
        <h3>–§–æ–Ω (–¥–≤–∏–∂–µ—Ç—Å—è –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ)</h3>
        <div class="grid">
          <div>
            <label>–§–æ–Ω ‚Äî URL</label>
            <input id="bgImgUrl" type="text" placeholder="https://..." />
            <div class="hint">–∏–ª–∏ –∑–∞–≥—Ä—É–∑–∏—Ç—å:</div>
            <input id="bgImgFile" type="file" accept="image/*" />
          </div>
          <div>
            <label>–ü—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Ñ–æ–Ω (–¥–ª—è Genially)</label>
            <select id="transparentBg">
              <option value="1" selected>–î–∞ (transparent)</option>
              <option value="0">–ù–µ—Ç (–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ñ–æ–Ω)</option>
            </select>

            <div style="margin-top:10px">
              <label>–°–∫–æ—Ä–æ—Å—Ç—å —Ñ–æ–Ω–∞ (px/—Å–µ–∫)</label>
              <div class="rangeRow">
                <input id="bgSpeedR" type="range" min="0" max="240" step="5" value="90" />
                <input id="bgSpeed" type="number" min="0" max="240" step="5" value="90" />
              </div>
            </div>

            <div style="margin-top:10px">
              <label>–†–∞–∑–º–µ—Ä —Ñ–æ–Ω–∞ –ø–æ —à–∏—Ä–∏–Ω–µ</label>
              <select id="bgSizeMode">
                <option value="auto" selected>auto (tile)</option>
                <option value="cover">cover</option>
                <option value="contain">contain</option>
              </select>
            </div>

            <div class="hint">–ß—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –≤–∏–¥–∏–º–æ–≥–æ —Å—Ç—ã–∫–∞, —Ñ–æ–Ω-–∫–∞—Ä—Ç–∏–Ω–∫–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å ¬´—Ç–∞–π–ª–æ–≤–æ–π¬ª (seamless). –ú—ã –¥–≤–∏–≥–∞–µ–º repeat-x.</div>
          </div>
        </div>
      </div>

      <!-- –ò–≥—Ä–æ–∫: –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ + –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä —Å–ø—Ä–∞–≤–∞ -->
      <div class="section">
        <h3>–ò–≥—Ä–æ–∫ (–∫–∞—Ä—Ç–∏–Ω–∫–∞ –±–µ–∑ –∫—Ä—É–≥–∞)</h3>

        <div class="sideBySide">
          <div>
            <div class="grid">
              <div>
                <label>–ö–∞—Ä—Ç–∏–Ω–∫–∞ –∏–≥—Ä–æ–∫–∞ ‚Äî URL</label>
                <input id="playerImgUrl" type="text" placeholder="https://..." />
                <div class="hint">–∏–ª–∏ –∑–∞–≥—Ä—É–∑–∏—Ç—å:</div>
                <input id="playerImgFile" type="file" accept="image/*" />
              </div>

              <div>
                <label>–†–∞–∑–º–µ—Ä –∏–≥—Ä–æ–∫–∞ (px)</label>
                <div class="rangeRow">
                  <input id="playerSizeR" type="range" min="32" max="240" step="1" value="86" />
                  <input id="playerSize" type="number" min="32" max="240" step="1" value="86" />
                </div>

                <div style="margin-top:10px" class="checkItem">
                  <input id="playerShadowOn" type="checkbox" />
                  <span>–¢–µ–Ω—å/–æ–±–≤–æ–¥–∫–∞ –ø–æ –∫–æ–Ω—Ç—É—Ä—É (drop-shadow)</span>
                </div>

                <div style="margin-top:10px">
                  <label>–¶–≤–µ—Ç –æ–±–≤–æ–¥–∫–∏/—Ç–µ–Ω–∏ –∏–≥—Ä–æ–∫–∞</label>
                  <input id="playerShadowColor" type="color" value="#000000" />
                </div>

                <div style="margin-top:10px">
                  <label>–°–∏–ª–∞ –æ–±–≤–æ–¥–∫–∏/—Ç–µ–Ω–∏</label>
                  <div class="rangeRow">
                    <input id="playerShadowStrengthR" type="range" min="0" max="40" step="1" value="18" />
                    <input id="playerShadowStrength" type="number" min="0" max="40" step="1" value="18" />
                  </div>
                </div>
              </div>
            </div>
            <div class="hint">–ü–∞—Ä–µ–Ω–∏–µ –∏ –Ω–∞–∫–ª–æ–Ω —Ä–∞–±–æ—Ç–∞—é—Ç –≤ –∏–≥—Ä–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.</div>
          </div>

          <div class="previewCard">
            <div class="previewCaption">–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –∏–≥—Ä–æ–∫–∞</div>
            <div id="playerPreviewImg" style="width:140px;height:140px;background:transparent center/contain no-repeat;"></div>
          </div>
        </div>
      </div>

      <!-- –û—Ç–≤–µ—Ç: –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ + –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä —Å–ø—Ä–∞–≤–∞ -->
      <div class="section">
        <h3>–û—Ç–≤–µ—Ç (–æ–±—ä–µ–∫—Ç)</h3>

        <div class="sideBySide">
          <div>
            <div class="grid">
              <div>
                <label>–ö–∞—Ä—Ç–∏–Ω–∫–∞ –æ—Ç–≤–µ—Ç–∞ (—Ñ–æ–Ω –æ–±—ä–µ–∫—Ç–∞) ‚Äî URL</label>
                <input id="answerCardImgUrl" type="text" placeholder="https://..." />
                <div class="hint">–∏–ª–∏ –∑–∞–≥—Ä—É–∑–∏—Ç—å:</div>
                <input id="answerCardImgFile" type="file" accept="image/*" />
              </div>

              <div>
                <label>–†–∞–∑–º–µ—Ä –æ–±—ä–µ–∫—Ç–∞ (px)</label>
                <div class="rangeRow">
                  <input id="answerSizeR" type="range" min="42" max="260" step="1" value="86" />
                  <input id="answerSize" type="number" min="42" max="260" step="1" value="86" />
                </div>

                <div style="margin-top:10px" class="checkItem">
                  <input id="answerTextBgOn" type="checkbox" checked />
                  <span>–ü–æ–¥–ª–æ–∂–∫–∞ –ø–æ–¥ —Ç–µ–∫—Å—Ç–æ–º</span>
                </div>
              </div>
            </div>

            <div class="hr"></div>

            <h3 style="margin:0 0 10px;">–¢–µ–∫—Å—Ç –Ω–∞ –æ–±—ä–µ–∫—Ç–µ</h3>
            <div class="grid">
              <div>
                <label>–ú–∞—Å—à—Ç–∞–± —Ç–µ–∫—Å—Ç–∞</label>
                <div class="rangeRow">
                  <input id="answerContentScaleR" type="range" min="0.6" max="2" step="0.05" value="1" />
                  <input id="answerContentScale" type="number" min="0.6" max="2" step="0.05" value="1" />
                </div>
              </div>
              <div>
                <label>–¢–µ–∫—Å—Ç –ø–æ X (%)</label>
                <div class="rangeRow">
                  <input id="answerTextXR" type="range" min="0" max="100" step="1" value="50" />
                  <input id="answerTextX" type="number" min="0" max="100" step="1" value="50" />
                </div>
              </div>
              <div>
                <label>–¢–µ–∫—Å—Ç –ø–æ Y (%)</label>
                <div class="rangeRow">
                  <input id="answerTextYR" type="range" min="0" max="100" step="1" value="64" />
                  <input id="answerTextY" type="number" min="0" max="100" step="1" value="64" />
                </div>
              </div>
            </div>

            <div class="hr"></div>

            <h3 style="margin:0 0 10px;">–ö–∞—Ä—Ç–∏–Ω–∫–∞ –æ–±—ä–µ–∫—Ç–∞</h3>
            <div class="grid">
              <div>
                <label>Fit</label>
                <select id="answerCardFit">
                  <option value="contain" selected>contain</option>
                  <option value="cover">cover</option>
                </select>
              </div>
              <div>
                <label>Scale</label>
                <div class="rangeRow">
                  <input id="answerCardScaleR" type="range" min="0.6" max="2" step="0.05" value="1" />
                  <input id="answerCardScale" type="number" min="0.6" max="2" step="0.05" value="1" />
                </div>
              </div>
              <div>
                <label>Pos X (%)</label>
                <div class="rangeRow">
                  <input id="answerCardPosXR" type="range" min="0" max="100" step="1" value="50" />
                  <input id="answerCardPosX" type="number" min="0" max="100" step="1" value="50" />
                </div>
              </div>
              <div>
                <label>Pos Y (%)</label>
                <div class="rangeRow">
                  <input id="answerCardPosYR" type="range" min="0" max="100" step="1" value="50" />
                  <input id="answerCardPosY" type="number" min="0" max="100" step="1" value="50" />
                </div>
              </div>
            </div>

            <div class="hint">–í –∏–≥—Ä–µ —É –æ—Ç–≤–µ—Ç–æ–≤ –ù–ï–¢ –ø–æ–¥–ª–æ–∂–∫–∏/—Ñ–æ–Ω–∞ ‚Äî —Ç–æ–ª—å–∫–æ –≤–∞—à–∞ –∫–∞—Ä—Ç–∏–Ω–∫–∞. –ë—É–∫–≤—ã –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç—Å—è.</div>
          </div>

          <div class="previewCard">
            <div class="previewCaption">–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –æ—Ç–≤–µ—Ç–∞</div>

            <div id="answerPreviewObj" style="width:170px;height:170px;position:relative;">
              <div id="answerPreviewBg"
                   style="position:absolute;inset:0;background:transparent center/contain no-repeat;transform:scale(1);">
              </div>

              <div id="answerPreviewText"
                   style="position:absolute;left:50%;top:64%;
                          transform:translate(-50%,-50%) scale(1);
                          text-align:center;
                          color:rgba(255,255,255,.95);
                          font-weight:800;
                          font-size:14px;
                          padding:6px 10px;
                          border-radius:10px;
                          border:1px solid rgba(255,255,255,.10);
                          background:rgba(0,0,0,.22);">
                –ü—Ä–∏–º–µ—Ä –æ—Ç–≤–µ—Ç–∞
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="section">
        <h3>–ü—Ä–∞–≤–∏–ª–∞ –∏–≥—Ä—ã</h3>
        <div class="grid">
          <div><label>–ñ–∏–∑–Ω–∏</label><input id="livesCount" type="number" min="1" max="10" value="3" /></div>
          <div><label>–û—á–∫–∏ –∑–∞ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π</label><input id="pointsPerCorrect" type="number" min="1" max="200" value="10" /></div>
          <div><label>–û—Ç–∫–∞—Ç –≤–æ–ø—Ä–æ—Å–æ–≤ (cooldown)</label><input id="cooldownTurns" type="number" min="0" max="10" value="3" /></div>
          <div><label>–°–∫–æ—Ä–æ—Å—Ç—å –∏–≥—Ä–æ–∫–∞</label><input id="playerSpeed" type="number" min="2" max="18" value="7" /></div>
        </div>
      </div>

      <div class="section">
        <h3>–°–∫–æ—Ä–æ—Å—Ç–∏ —É—Ä–æ–≤–Ω–µ–π</h3>
        <div class="hint">–°–∫–æ—Ä–æ—Å—Ç—å ‚Äî –Ω–∞—Å–∫–æ–ª—å–∫–æ –±—ã—Å—Ç—Ä–æ –ª–µ—Ç—è—Ç –æ—Ç–≤–µ—Ç—ã. –ß–∞—Å—Ç–æ—Ç–∞ ‚Äî –∫–∞–∫ —á–∞—Å—Ç–æ –æ–Ω–∏ –ø–æ—è–≤–ª—è—é—Ç—Å—è.</div>

        <div class="hr"></div>
        <h3 style="margin:0 0 10px;">–õ—ë–≥–∫–∏–π</h3>
        <div class="grid">
          <div>
            <label>–°–∫–æ—Ä–æ—Å—Ç—å</label>
            <div class="rangeRow">
              <input id="easySpeedR" type="range" min="0.8" max="8" step="0.1" value="2.4" />
              <input id="easySpeed" type="number" min="0.8" max="8" step="0.1" value="2.4" />
            </div>
          </div>
          <div>
            <label>–ß–∞—Å—Ç–æ—Ç–∞ –ø–æ—è–≤–ª–µ–Ω–∏—è (–º—Å)</label>
            <div class="rangeRow">
              <input id="easySpawnR" type="range" min="350" max="2200" step="10" value="1050" />
              <input id="easySpawn" type="number" min="350" max="2200" step="10" value="1050" />
            </div>
          </div>
        </div>

        <div class="hr"></div>
        <h3 style="margin:0 0 10px;">–°—Ä–µ–¥–Ω–∏–π</h3>
        <div class="grid">
          <div>
            <label>–°–∫–æ—Ä–æ—Å—Ç—å</label>
            <div class="rangeRow">
              <input id="medSpeedR" type="range" min="0.8" max="8" step="0.1" value="3.2" />
              <input id="medSpeed" type="number" min="0.8" max="8" step="0.1" value="3.2" />
            </div>
          </div>
          <div>
            <label>–ß–∞—Å—Ç–æ—Ç–∞ –ø–æ—è–≤–ª–µ–Ω–∏—è (–º—Å)</label>
            <div class="rangeRow">
              <input id="medSpawnR" type="range" min="350" max="2200" step="10" value="900" />
              <input id="medSpawn" type="number" min="350" max="2200" step="10" value="900" />
            </div>
          </div>
        </div>

        <div class="hr"></div>
        <h3 style="margin:0 0 10px;">–°–ª–æ–∂–Ω—ã–π</h3>
        <div class="grid">
          <div>
            <label>–°–∫–æ—Ä–æ—Å—Ç—å</label>
            <div class="rangeRow">
              <input id="hardSpeedR" type="range" min="0.8" max="8" step="0.1" value="4.1" />
              <input id="hardSpeed" type="number" min="0.8" max="8" step="0.1" value="4.1" />
            </div>
          </div>
          <div>
            <label>–ß–∞—Å—Ç–æ—Ç–∞ –ø–æ—è–≤–ª–µ–Ω–∏—è (–º—Å)</label>
            <div class="rangeRow">
              <input id="hardSpawnR" type="range" min="350" max="2200" step="10" value="760" />
              <input id="hardSpawn" type="number" min="350" max="2200" step="10" value="760" />
            </div>
          </div>
        </div>
      </div>

      <div class="section">
        <h3>–§—Ä–∞–∑—ã –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑–∏</h3>
        <div class="grid">
          <div><label>–ü—Ä–∞–≤–∏–ª—å–Ω–æ (–∫–æ—Ä–æ—Ç–∫–∞—è —Ñ—Ä–∞–∑–∞)</label><input id="hitOkText" type="text" value="–í–µ—Ä–Ω–æ!" /></div>
          <div><label>–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ (–∫–æ—Ä–æ—Ç–∫–∞—è —Ñ—Ä–∞–∑–∞)</label><input id="hitBadText" type="text" value="–ù–µ–≤–µ—Ä–Ω–æ!" /></div>
          <div><label>–ü–æ–±–µ–¥–∞ (—Ñ–∏–Ω–∞–ª—å–Ω–∞—è —Ñ—Ä–∞–∑–∞)</label><input id="finalWinText" type="text" value="–¢—ã –ø–æ–±–µ–¥–∏–ª(–∞)! –û—Ç–ª–∏—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞ üëè" /></div>
          <div><label>–ü–æ—Ä–∞–∂–µ–Ω–∏–µ (—Ñ–∏–Ω–∞–ª—å–Ω–∞—è —Ñ—Ä–∞–∑–∞)</label><input id="finalLoseText" type="text" value="–ù–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å —Å–µ–π—á–∞—Å ‚Äî –ø–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑ üí™" /></div>
        </div>
      </div>

      <div class="section">
        <h3>–í–æ–ø—Ä–æ—Å—ã –∏ –≤–∞—Ä–∏–∞–Ω—Ç—ã</h3>
        <div class="row">
          <button class="btn miniBtn" id="addQuestionBtn">+ –î–æ–±–∞–≤–∏—Ç—å –≤–æ–ø—Ä–æ—Å</button>
          <button class="btn miniBtn danger" id="resetQuestionsBtn">–°–±—Ä–æ—Å–∏—Ç—å –¥–µ–º–æ</button>
        </div>
        <div class="hint">–ì–∞–ª–æ—á–∫–∞ ‚Äú–≤–µ—Ä–Ω—ã–π‚Äù –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —Ä–æ–≤–Ω–æ —É –æ–¥–Ω–æ–≥–æ –≤–∞—Ä–∏–∞–Ω—Ç–∞. –ë—É–∫–≤—ã –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤ –Ω–µ –ø–æ–∫–∞–∑—ã–≤–∞—é—Ç—Å—è –≤ –∏–≥—Ä–µ.</div>
        <div id="questionsList" style="margin-top:10px;"></div>
      </div>

      <div class="section">
        <h3>iframe –¥–ª—è Genially</h3>
        <div class="row">
          <button class="btn primary" id="genIframeBtn">–°–æ–∑–¥–∞—Ç—å iframe</button>
          <button class="btn" id="copyIframeBtn">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
        </div>
        <textarea id="codeBox" readonly placeholder="–¢—É—Ç –ø–æ—è–≤–∏—Ç—Å—è iframe..."></textarea>
      </div>

      <div class="hint">–í—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–∏–º–µ–Ω—è—é—Ç—Å—è –≤ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä —Å–ø—Ä–∞–≤–∞.</div>
    </div>
  </div>

  <div id="right" class="panel">
    <div class="head">
      <div>
        <h1>–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –∏–≥—Ä—ã</h1>
        <div class="sub">–û–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º.</div>
      </div>
      <div class="badge">play</div>
    </div>
    <div id="previewWrap">
      <iframe id="previewFrame" title="preview"></iframe>
    </div>
  </div>
</div>

<div id="gameRoot" style="display:none;"></div>

<script>
/* ===== helpers ===== */
function b64urlEncode(str){
  const b64 = btoa(unescape(encodeURIComponent(str)));
  return b64.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
}
function b64urlDecode(b64url){
  let b64 = b64url.replace(/-/g,'+').replace(/_/g,'/');
  while(b64.length % 4) b64 += '=';
  return decodeURIComponent(escape(atob(b64)));
}
function deepClone(o){ return JSON.parse(JSON.stringify(o)); }
function cssUrl(u){ return String(u||"").replace(/'/g,"%27"); }
function escapeCss(s){ return String(s||"").replace(/</g,"").replace(/>/g,"").replace(/"/g,""); }
function clampNum(v,a,b,d){ const n=Number(v); if(!Number.isFinite(n)) return d; return Math.max(a, Math.min(b, n)); }
function clampInt(v,a,b,d){ const n=Number(v); if(!Number.isFinite(n)) return d; return Math.max(a, Math.min(b, Math.round(n))); }
function hexToRgba(hex, alpha){
  const h=String(hex||"").replace("#","");
  if(h.length!==6) return `rgba(255,255,255,${alpha})`;
  const r=parseInt(h.slice(0,2),16), g=parseInt(h.slice(2,4),16), b=parseInt(h.slice(4,6),16);
  return `rgba(${r},${g},${b},${alpha})`;
}
function pairSync(rangeEl, numberEl, v){ rangeEl.value = String(v); numberEl.value = String(v); }
function pairBind(rangeEl, numberEl, onChange){
  rangeEl.addEventListener("input", ()=>{ numberEl.value = rangeEl.value; onChange(); });
  numberEl.addEventListener("input", ()=>{ rangeEl.value = numberEl.value; onChange(); });
  rangeEl.addEventListener("change", ()=>{ numberEl.value = rangeEl.value; onChange(); });
  numberEl.addEventListener("change", ()=>{ rangeEl.value = numberEl.value; onChange(); });
}
async function fileToDataUrl(file){
  return new Promise((res, rej)=>{
    const r = new FileReader();
    r.onload = ()=>res(String(r.result||""));
    r.onerror = rej;
    r.readAsDataURL(file);
  });
}

/* ===== cfg ===== */
const DEFAULT_CFG = {
  fontFamily: "system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif",
  fontWeight: 900,

  questionSize: 24,
  questionColor: "#ffffff",
  questionBgColor: "#0a0a14",
  questionBorderColor: "#ffffff",

  hudTextColor: "#ffffff",
  hudPanelColor: "#0f0f19",
  scoreSize: 24,
  livesSize: 24,

  progressHeight: 30,
  progressColor: "#7a5aff",

  iconColor: "#7a5aff",
  btnColor: "#7a5aff",
  btnTextColor: "#ffffff",

  transparentBg: true,
  bgImg: "",
  bgSpeed: 90,
  bgSizeMode: "auto",

  playerImg: "",
  playerSize: 86,
  playerShadowOn: false,
  playerShadowColor: "#000000",
  playerShadowStrength: 18,

  answerCardImg: "",
  answerSize: 86,
  answerTextBgOn: true,

  answerContentScale: 1,
  answerTextX: 50,
  answerTextY: 64,

  answerCardFit: "contain",
  answerCardScale: 1,
  answerCardPosX: 50,
  answerCardPosY: 50,

  livesCount: 3,
  pointsPerCorrect: 10,
  cooldownTurns: 3,
  playerSpeed: 7,

  hitOkText: "–í–µ—Ä–Ω–æ!",
  hitBadText: "–ù–µ–≤–µ—Ä–Ω–æ!",
  finalWinText: "–¢—ã –ø–æ–±–µ–¥–∏–ª(–∞)! –û—Ç–ª–∏—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞ üëè",
  finalLoseText: "–ù–µ –ø–æ–ª—É—á–∏–ª–æ—Å—å —Å–µ–π—á–∞—Å ‚Äî –ø–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑ üí™",

  difficulty: {
    easy:   { speed: 2.4, spawnEveryMs: 1050, minXGap: 220, maxOnScreen: 4 },
    medium: { speed: 3.2, spawnEveryMs:  900, minXGap: 200, maxOnScreen: 5 },
    hard:   { speed: 4.1, spawnEveryMs:  760, minXGap: 180, maxOnScreen: 6 },
  },

  questions: [
    { q:"–°—Ç–æ–ª–∏—Ü–∞ –§—Ä–∞–Ω—Ü–∏–∏?", answers:[
      {label:"A", text:"–ü–∞—Ä–∏–∂",  correct:true},
      {label:"B", text:"–†–∏–º",    correct:false},
      {label:"C", text:"–ë–µ—Ä–ª–∏–Ω", correct:false},
    ]},
    { q:"2 + 2 = ?", answers:[
      {label:"A", text:"3", correct:false},
      {label:"B", text:"4", correct:true},
      {label:"C", text:"5", correct:false},
    ]},
  ]
};

const params = new URLSearchParams(location.search);
const mode = params.get("mode");

if(mode === "play"){
  document.getElementById("gameRoot").style.display = "block";
  startGameMode();
} else {
  document.getElementById("editorApp").style.display = "flex";
  startEditorMode();
}

/* ================= EDITOR ================= */
function startEditorMode(){
  const els = {
    baseUrl: document.getElementById("baseUrl"),
    cfgSizeBadge: document.getElementById("cfgSizeBadge"),
    previewFrame: document.getElementById("previewFrame"),

    fontFamily: document.getElementById("fontFamily"),
    fontWeight: document.getElementById("fontWeight"),

    questionSize: document.getElementById("questionSize"),
    questionColor: document.getElementById("questionColor"),
    questionBgColor: document.getElementById("questionBgColor"),
    questionBorderColor: document.getElementById("questionBorderColor"),

    scoreSize: document.getElementById("scoreSize"),
    livesSize: document.getElementById("livesSize"),
    hudTextColor: document.getElementById("hudTextColor"),
    hudPanelColor: document.getElementById("hudPanelColor"),

    iconColor: document.getElementById("iconColor"),
    btnColor: document.getElementById("btnColor"),
    btnTextColor: document.getElementById("btnTextColor"),
    progressColor: document.getElementById("progressColor"),
    progressHeight: document.getElementById("progressHeight"),

    bgImgUrl: document.getElementById("bgImgUrl"),
    bgImgFile: document.getElementById("bgImgFile"),
    transparentBg: document.getElementById("transparentBg"),
    bgSpeedR: document.getElementById("bgSpeedR"),
    bgSpeed: document.getElementById("bgSpeed"),
    bgSizeMode: document.getElementById("bgSizeMode"),

    playerImgUrl: document.getElementById("playerImgUrl"),
    playerImgFile: document.getElementById("playerImgFile"),
    playerSizeR: document.getElementById("playerSizeR"),
    playerSize: document.getElementById("playerSize"),
    playerShadowOn: document.getElementById("playerShadowOn"),
    playerShadowColor: document.getElementById("playerShadowColor"),
    playerShadowStrengthR: document.getElementById("playerShadowStrengthR"),
    playerShadowStrength: document.getElementById("playerShadowStrength"),

    playerPreviewImg: document.getElementById("playerPreviewImg"),

    answerCardImgUrl: document.getElementById("answerCardImgUrl"),
    answerCardImgFile: document.getElementById("answerCardImgFile"),
    answerSizeR: document.getElementById("answerSizeR"),
    answerSize: document.getElementById("answerSize"),
    answerTextBgOn: document.getElementById("answerTextBgOn"),

    answerContentScaleR: document.getElementById("answerContentScaleR"),
    answerContentScale: document.getElementById("answerContentScale"),
    answerTextXR: document.getElementById("answerTextXR"),
    answerTextX: document.getElementById("answerTextX"),
    answerTextYR: document.getElementById("answerTextYR"),
    answerTextY: document.getElementById("answerTextY"),

    answerCardFit: document.getElementById("answerCardFit"),
    answerCardScaleR: document.getElementById("answerCardScaleR"),
    answerCardScale: document.getElementById("answerCardScale"),
    answerCardPosXR: document.getElementById("answerCardPosXR"),
    answerCardPosX: document.getElementById("answerCardPosX"),
    answerCardPosYR: document.getElementById("answerCardPosYR"),
    answerCardPosY: document.getElementById("answerCardPosY"),

    answerPreviewObj: document.getElementById("answerPreviewObj"),
    answerPreviewBg: document.getElementById("answerPreviewBg"),
    answerPreviewText: document.getElementById("answerPreviewText"),

    livesCount: document.getElementById("livesCount"),
    pointsPerCorrect: document.getElementById("pointsPerCorrect"),
    cooldownTurns: document.getElementById("cooldownTurns"),
    playerSpeed: document.getElementById("playerSpeed"),

    easySpeedR: document.getElementById("easySpeedR"),
    easySpeed: document.getElementById("easySpeed"),
    easySpawnR: document.getElementById("easySpawnR"),
    easySpawn: document.getElementById("easySpawn"),

    medSpeedR: document.getElementById("medSpeedR"),
    medSpeed: document.getElementById("medSpeed"),
    medSpawnR: document.getElementById("medSpawnR"),
    medSpawn: document.getElementById("medSpawn"),

    hardSpeedR: document.getElementById("hardSpeedR"),
    hardSpeed: document.getElementById("hardSpeed"),
    hardSpawnR: document.getElementById("hardSpawnR"),
    hardSpawn: document.getElementById("hardSpawn"),

    hitOkText: document.getElementById("hitOkText"),
    hitBadText: document.getElementById("hitBadText"),
    finalWinText: document.getElementById("finalWinText"),
    finalLoseText: document.getElementById("finalLoseText"),

    questionsList: document.getElementById("questionsList"),
    addQuestionBtn: document.getElementById("addQuestionBtn"),
    resetQuestionsBtn: document.getElementById("resetQuestionsBtn"),

    genIframeBtn: document.getElementById("genIframeBtn"),
    copyIframeBtn: document.getElementById("copyIframeBtn"),
    codeBox: document.getElementById("codeBox"),
  };

  els.baseUrl.value = location.origin + location.pathname;

  let cfgDraft = deepClone(DEFAULT_CFG);

  function makeEmptyQuestion(){
    return { q:"", answers:[
      {label:"A", text:"", correct:true},
      {label:"B", text:"", correct:false},
      {label:"C", text:"", correct:false},
    ]};
  }
  function nextLabel(arr){
    const base="ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    const used=new Set(arr.map(x=>String(x.label||"").trim().toUpperCase()));
    for(const c of base){ if(!used.has(c)) return c; }
    return "X";
  }

  function cfgToUI(){
    els.fontFamily.value = cfgDraft.fontFamily;
    els.fontWeight.value = String(cfgDraft.fontWeight);

    els.questionSize.value = cfgDraft.questionSize;
    els.questionColor.value = cfgDraft.questionColor;
    els.questionBgColor.value = cfgDraft.questionBgColor;
    els.questionBorderColor.value = cfgDraft.questionBorderColor;

    els.scoreSize.value = cfgDraft.scoreSize;
    els.livesSize.value = cfgDraft.livesSize;
    els.hudTextColor.value = cfgDraft.hudTextColor;
    els.hudPanelColor.value = cfgDraft.hudPanelColor;

    els.iconColor.value = cfgDraft.iconColor;
    els.btnColor.value = cfgDraft.btnColor;
    els.btnTextColor.value = cfgDraft.btnTextColor;
    els.progressColor.value = cfgDraft.progressColor;
    els.progressHeight.value = cfgDraft.progressHeight;

    els.transparentBg.value = cfgDraft.transparentBg ? "1" : "0";
    els.bgImgUrl.value = (cfgDraft.bgImg && cfgDraft.bgImg.startsWith("http")) ? cfgDraft.bgImg : "";
    els.bgSizeMode.value = ["auto","cover","contain"].includes(cfgDraft.bgSizeMode) ? cfgDraft.bgSizeMode : "auto";
    pairSync(els.bgSpeedR, els.bgSpeed, cfgDraft.bgSpeed ?? 90);

    els.playerImgUrl.value = (cfgDraft.playerImg && cfgDraft.playerImg.startsWith("http")) ? cfgDraft.playerImg : "";
    pairSync(els.playerSizeR, els.playerSize, cfgDraft.playerSize ?? 86);
    els.playerShadowOn.checked = !!cfgDraft.playerShadowOn;
    els.playerShadowColor.value = cfgDraft.playerShadowColor || "#000000";
    pairSync(els.playerShadowStrengthR, els.playerShadowStrength, cfgDraft.playerShadowStrength ?? 18);

    els.answerCardImgUrl.value = (cfgDraft.answerCardImg && cfgDraft.answerCardImg.startsWith("http")) ? cfgDraft.answerCardImg : "";
    pairSync(els.answerSizeR, els.answerSize, cfgDraft.answerSize ?? 86);
    els.answerTextBgOn.checked = cfgDraft.answerTextBgOn !== false;

    pairSync(els.answerContentScaleR, els.answerContentScale, cfgDraft.answerContentScale ?? 1);
    pairSync(els.answerTextXR, els.answerTextX, cfgDraft.answerTextX ?? 50);
    pairSync(els.answerTextYR, els.answerTextY, cfgDraft.answerTextY ?? 64);

    els.answerCardFit.value = (cfgDraft.answerCardFit === "cover") ? "cover" : "contain";
    pairSync(els.answerCardScaleR, els.answerCardScale, cfgDraft.answerCardScale ?? 1);
    pairSync(els.answerCardPosXR, els.answerCardPosX, cfgDraft.answerCardPosX ?? 50);
    pairSync(els.answerCardPosYR, els.answerCardPosY, cfgDraft.answerCardPosY ?? 50);

    els.livesCount.value = cfgDraft.livesCount;
    els.pointsPerCorrect.value = cfgDraft.pointsPerCorrect;
    els.cooldownTurns.value = cfgDraft.cooldownTurns;
    els.playerSpeed.value = cfgDraft.playerSpeed;

    pairSync(els.easySpeedR, els.easySpeed, cfgDraft.difficulty.easy.speed);
    pairSync(els.easySpawnR, els.easySpawn, cfgDraft.difficulty.easy.spawnEveryMs);
    pairSync(els.medSpeedR, els.medSpeed, cfgDraft.difficulty.medium.speed);
    pairSync(els.medSpawnR, els.medSpawn, cfgDraft.difficulty.medium.spawnEveryMs);
    pairSync(els.hardSpeedR, els.hardSpeed, cfgDraft.difficulty.hard.speed);
    pairSync(els.hardSpawnR, els.hardSpawn, cfgDraft.difficulty.hard.spawnEveryMs);

    els.hitOkText.value = cfgDraft.hitOkText || "";
    els.hitBadText.value = cfgDraft.hitBadText || "";
    els.finalWinText.value = cfgDraft.finalWinText || "";
    els.finalLoseText.value = cfgDraft.finalLoseText || "";
  }

  function readUIIntoDraft(){
    cfgDraft.fontFamily = els.fontFamily.value;
    cfgDraft.fontWeight = Number(els.fontWeight.value || 900);

    cfgDraft.questionSize = clampInt(els.questionSize.value, 12, 70, 24);
    cfgDraft.questionColor = els.questionColor.value;
    cfgDraft.questionBgColor = els.questionBgColor.value;
    cfgDraft.questionBorderColor = els.questionBorderColor.value;

    cfgDraft.scoreSize = clampInt(els.scoreSize.value, 12, 70, 24);
    cfgDraft.livesSize = clampInt(els.livesSize.value, 12, 70, 24);
    cfgDraft.hudTextColor = els.hudTextColor.value;
    cfgDraft.hudPanelColor = els.hudPanelColor.value;

    cfgDraft.iconColor = els.iconColor.value;
    cfgDraft.btnColor = els.btnColor.value;
    cfgDraft.btnTextColor = els.btnTextColor.value;
    cfgDraft.progressColor = els.progressColor.value;
    cfgDraft.progressHeight = clampInt(els.progressHeight.value, 14, 70, 30);

    cfgDraft.transparentBg = els.transparentBg.value === "1";
    cfgDraft.bgSizeMode = els.bgSizeMode.value;
    cfgDraft.bgSpeed = clampInt(els.bgSpeed.value, 0, 240, 90);

    cfgDraft.playerSize = clampInt(els.playerSize.value, 32, 240, 86);
    cfgDraft.playerShadowOn = !!els.playerShadowOn.checked;
    cfgDraft.playerShadowColor = els.playerShadowColor.value || "#000000";
    cfgDraft.playerShadowStrength = clampInt(els.playerShadowStrength.value, 0, 40, 18);

    cfgDraft.answerSize = clampInt(els.answerSize.value, 42, 260, 86);
    cfgDraft.answerTextBgOn = !!els.answerTextBgOn.checked;

    cfgDraft.answerContentScale = clampNum(els.answerContentScale.value, 0.6, 2, 1);
    cfgDraft.answerTextX = clampNum(els.answerTextX.value, 0, 100, 50);
    cfgDraft.answerTextY = clampNum(els.answerTextY.value, 0, 100, 64);

    cfgDraft.answerCardFit = (els.answerCardFit.value === "cover") ? "cover" : "contain";
    cfgDraft.answerCardScale = clampNum(els.answerCardScale.value, 0.6, 2, 1);
    cfgDraft.answerCardPosX = clampNum(els.answerCardPosX.value, 0, 100, 50);
    cfgDraft.answerCardPosY = clampNum(els.answerCardPosY.value, 0, 100, 50);

    cfgDraft.livesCount = clampInt(els.livesCount.value, 1, 10, 3);
    cfgDraft.pointsPerCorrect = clampInt(els.pointsPerCorrect.value, 1, 200, 10);
    cfgDraft.cooldownTurns = clampInt(els.cooldownTurns.value, 0, 10, 3);
    cfgDraft.playerSpeed = clampInt(els.playerSpeed.value, 2, 18, 7);

    cfgDraft.difficulty.easy.speed = clampNum(els.easySpeed.value, 0.8, 8, 2.4);
    cfgDraft.difficulty.easy.spawnEveryMs = clampInt(els.easySpawn.value, 350, 2200, 1050);

    cfgDraft.difficulty.medium.speed = clampNum(els.medSpeed.value, 0.8, 8, 3.2);
    cfgDraft.difficulty.medium.spawnEveryMs = clampInt(els.medSpawn.value, 350, 2200, 900);

    cfgDraft.difficulty.hard.speed = clampNum(els.hardSpeed.value, 0.8, 8, 4.1);
    cfgDraft.difficulty.hard.spawnEveryMs = clampInt(els.hardSpawn.value, 350, 2200, 760);

    cfgDraft.hitOkText = els.hitOkText.value || "";
    cfgDraft.hitBadText = els.hitBadText.value || "";
    cfgDraft.finalWinText = els.finalWinText.value || "";
    cfgDraft.finalLoseText = els.finalLoseText.value || "";

    if(els.bgImgUrl.value.trim().startsWith("http")) cfgDraft.bgImg = els.bgImgUrl.value.trim();
    if(els.playerImgUrl.value.trim().startsWith("http")) cfgDraft.playerImg = els.playerImgUrl.value.trim();
    if(els.answerCardImgUrl.value.trim().startsWith("http")) cfgDraft.answerCardImg = els.answerCardImgUrl.value.trim();
  }

  function updateInlinePreviews(){
    // –ò–≥—Ä–æ–∫
    const pSize = cfgDraft.playerSize ?? 86;
    els.playerPreviewImg.style.width = pSize + "px";
    els.playerPreviewImg.style.height = pSize + "px";
    els.playerPreviewImg.style.backgroundImage = cfgDraft.playerImg ? `url('${cssUrl(cfgDraft.playerImg)}')` : "none";
    const shadowOn = !!cfgDraft.playerShadowOn;
    const s = cfgDraft.playerShadowStrength ?? 18;
    const sc = cfgDraft.playerShadowColor || "#000000";
    els.playerPreviewImg.style.filter = shadowOn ? `drop-shadow(0 0 ${Math.max(0, s)}px ${hexToRgba(sc, 0.85)})` : "none";

    // –û—Ç–≤–µ—Ç
    const aSize = cfgDraft.answerSize ?? 86;
    els.answerPreviewObj.style.width = Math.max(140, aSize + 60) + "px";
    els.answerPreviewObj.style.height = Math.max(140, aSize + 60) + "px";

    els.answerPreviewBg.style.backgroundImage = cfgDraft.answerCardImg ? `url('${cssUrl(cfgDraft.answerCardImg)}')` : "none";
    els.answerPreviewBg.style.backgroundSize = cfgDraft.answerCardFit === "cover" ? "cover" : "contain";
    els.answerPreviewBg.style.backgroundPosition = `${cfgDraft.answerCardPosX ?? 50}% ${cfgDraft.answerCardPosY ?? 50}%`;
    els.answerPreviewBg.style.transform = `scale(${cfgDraft.answerCardScale ?? 1})`;

    els.answerPreviewText.style.left = (cfgDraft.answerTextX ?? 50) + "%";
    els.answerPreviewText.style.top  = (cfgDraft.answerTextY ?? 64) + "%";
    els.answerPreviewText.style.transform = `translate(-50%,-50%) scale(${cfgDraft.answerContentScale ?? 1})`;
    els.answerPreviewText.style.background = (cfgDraft.answerTextBgOn === false) ? "transparent" : "rgba(0,0,0,.22)";
    els.answerPreviewText.style.border = (cfgDraft.answerTextBgOn === false) ? "0" : "1px solid rgba(255,255,255,.10)";
    els.answerPreviewText.style.padding = (cfgDraft.answerTextBgOn === false) ? "0" : "6px 10px";
  }

  function buildCfgParam(fromCfg){
    const c = deepClone(fromCfg);
    // –Ω–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –≤–æ–ø—Ä–æ—Å–æ–≤
    if(!c.questions?.length) c.questions = [makeEmptyQuestion()];
    c.questions.forEach(q=>{
      if(!q.answers?.length) q.answers = [{label:"A", text:"", correct:true},{label:"B", text:"", correct:false}];
      if(!q.answers.some(a=>a.correct)) q.answers[0].correct = true;
    });
    return b64urlEncode(JSON.stringify(c));
  }

  function buildPlayUrlForPreview(fromCfg){
    const base = location.origin + location.pathname;
    const enc = buildCfgParam(fromCfg);
    els.cfgSizeBadge.textContent = `cfg: ${Math.round(enc.length/1024*10)/10}KB`;
    return `${base}?mode=play&cfg=${enc}&v=${Date.now()}`;
  }
  function buildPlayUrlForIframe(fromCfg){
    const base = (els.baseUrl.value.trim() || (location.origin + location.pathname));
    const enc = buildCfgParam(fromCfg);
    els.cfgSizeBadge.textContent = `cfg: ${Math.round(enc.length/1024*10)/10}KB`;
    return `${base}?mode=play&cfg=${enc}&v=${Date.now()}`;
  }

  let autoTimer = null;
  function scheduleAutoPreview(){
    readUIIntoDraft();
    updateInlinePreviews();
    if(autoTimer) clearTimeout(autoTimer);
    autoTimer = setTimeout(()=>applyPreviewNow(), 180);
  }
  function applyPreviewNow(){
    readUIIntoDraft();
    updateInlinePreviews();
    const url = buildPlayUrlForPreview(cfgDraft);
    els.previewFrame.src = "about:blank";
    requestAnimationFrame(()=>{ els.previewFrame.src = url; });
  }

  function renderQuestions(){
    els.questionsList.innerHTML = "";
    cfgDraft.questions.forEach((q, qi)=>{
      const wrap = document.createElement("div");
      wrap.className = "qitem";

      const top = document.createElement("div");
      top.className = "qtop";

      const title = document.createElement("strong");
      title.textContent = `–í–æ–ø—Ä–æ—Å ${qi+1}`;

      const delQ = document.createElement("button");
      delQ.className = "btn miniBtn danger";
      delQ.textContent = "–£–¥–∞–ª–∏—Ç—å";
      delQ.onclick = ()=>{
        cfgDraft.questions.splice(qi,1);
        if(cfgDraft.questions.length === 0) cfgDraft.questions.push(makeEmptyQuestion());
        renderQuestions();
        scheduleAutoPreview();
      };
      top.appendChild(title); top.appendChild(delQ);

      const qInput = document.createElement("input");
      qInput.type = "text";
      qInput.value = q.q || "";
      qInput.placeholder = "–¢–µ–∫—Å—Ç –≤–æ–ø—Ä–æ—Å–∞...";
      qInput.oninput = ()=>{ cfgDraft.questions[qi].q = qInput.value; scheduleAutoPreview(); };

      const answers = document.createElement("div");
      answers.className = "answers";

      cfgDraft.questions[qi].answers.forEach((a, ai)=>{
        const row = document.createElement("div");
        row.className = "ansRow";

        const txt = document.createElement("input");
        txt.type = "text";
        txt.value = a.text || "";
        txt.placeholder = "–¢–µ–∫—Å—Ç –≤–∞—Ä–∏–∞–Ω—Ç–∞...";
        txt.oninput = ()=>{ cfgDraft.questions[qi].answers[ai].text = txt.value; scheduleAutoPreview(); };

        const right = document.createElement("div");
        right.className = "chk";
        const chk = document.createElement("input");
        chk.type = "checkbox";
        chk.checked = !!a.correct;
        chk.onchange = ()=>{
          cfgDraft.questions[qi].answers.forEach(x=>x.correct=false);
          cfgDraft.questions[qi].answers[ai].correct = chk.checked;
          renderQuestions();
          scheduleAutoPreview();
        };
        right.appendChild(chk);
        right.appendChild(Object.assign(document.createElement("span"), {textContent:"–≤–µ—Ä–Ω—ã–π"}));

        row.appendChild(txt); row.appendChild(right);
        answers.appendChild(row);
      });

      const qButtons = document.createElement("div");
      qButtons.className = "row";
      qButtons.style.marginTop = "10px";

      const addA = document.createElement("button");
      addA.className = "btn miniBtn";
      addA.textContent = "+ –í–∞—Ä–∏–∞–Ω—Ç";
      addA.onclick = ()=>{
        cfgDraft.questions[qi].answers.push({label: nextLabel(cfgDraft.questions[qi].answers), text:"", correct:false});
        renderQuestions();
        scheduleAutoPreview();
      };

      const delA = document.createElement("button");
      delA.className = "btn miniBtn danger";
      delA.textContent = "‚àí –í–∞—Ä–∏–∞–Ω—Ç";
      delA.onclick = ()=>{
        if(cfgDraft.questions[qi].answers.length <= 2) return;
        cfgDraft.questions[qi].answers.pop();
        if(!cfgDraft.questions[qi].answers.some(x=>x.correct)) cfgDraft.questions[qi].answers[0].correct = true;
        renderQuestions();
        scheduleAutoPreview();
      };

      qButtons.appendChild(addA); qButtons.appendChild(delA);

      wrap.appendChild(top);
      wrap.appendChild(qInput);
      wrap.appendChild(document.createElement("div")).className="hr";
      wrap.appendChild(answers);
      wrap.appendChild(qButtons);

      els.questionsList.appendChild(wrap);
    });
  }

  // file uploads
  els.bgImgFile.addEventListener("change", async ()=>{
    const f = els.bgImgFile.files?.[0]; if(!f) return;
    cfgDraft.bgImg = await fileToDataUrl(f);
    els.bgImgUrl.value = "";
    scheduleAutoPreview();
  });
  els.playerImgFile.addEventListener("change", async ()=>{
    const f = els.playerImgFile.files?.[0]; if(!f) return;
    cfgDraft.playerImg = await fileToDataUrl(f);
    els.playerImgUrl.value = "";
    scheduleAutoPreview();
  });
  els.answerCardImgFile.addEventListener("change", async ()=>{
    const f = els.answerCardImgFile.files?.[0]; if(!f) return;
    cfgDraft.answerCardImg = await fileToDataUrl(f);
    els.answerCardImgUrl.value = "";
    scheduleAutoPreview();
  });

  const bind = (el)=>{ el.addEventListener("input", scheduleAutoPreview); el.addEventListener("change", scheduleAutoPreview); };

  [
    els.baseUrl,
    els.fontFamily, els.fontWeight,
    els.questionSize, els.questionColor, els.questionBgColor, els.questionBorderColor,
    els.scoreSize, els.livesSize, els.hudTextColor, els.hudPanelColor,
    els.iconColor, els.btnColor, els.btnTextColor,
    els.progressColor, els.progressHeight,

    els.bgImgUrl, els.transparentBg, els.bgSizeMode,

    els.playerImgUrl, els.playerShadowOn, els.playerShadowColor,
    els.answerCardImgUrl, els.answerTextBgOn, els.answerCardFit,

    els.livesCount, els.pointsPerCorrect, els.cooldownTurns, els.playerSpeed,

    els.hitOkText, els.hitBadText, els.finalWinText, els.finalLoseText,
  ].forEach(bind);

  pairBind(els.bgSpeedR, els.bgSpeed, scheduleAutoPreview);

  pairBind(els.playerSizeR, els.playerSize, scheduleAutoPreview);
  pairBind(els.playerShadowStrengthR, els.playerShadowStrength, scheduleAutoPreview);

  pairBind(els.answerSizeR, els.answerSize, scheduleAutoPreview);
  pairBind(els.answerContentScaleR, els.answerContentScale, scheduleAutoPreview);
  pairBind(els.answerTextXR, els.answerTextX, scheduleAutoPreview);
  pairBind(els.answerTextYR, els.answerTextY, scheduleAutoPreview);
  pairBind(els.answerCardScaleR, els.answerCardScale, scheduleAutoPreview);
  pairBind(els.answerCardPosXR, els.answerCardPosX, scheduleAutoPreview);
  pairBind(els.answerCardPosYR, els.answerCardPosY, scheduleAutoPreview);

  pairBind(els.easySpeedR, els.easySpeed, scheduleAutoPreview);
  pairBind(els.easySpawnR, els.easySpawn, scheduleAutoPreview);
  pairBind(els.medSpeedR, els.medSpeed, scheduleAutoPreview);
  pairBind(els.medSpawnR, els.medSpawn, scheduleAutoPreview);
  pairBind(els.hardSpeedR, els.hardSpeed, scheduleAutoPreview);
  pairBind(els.hardSpawnR, els.hardSpawn, scheduleAutoPreview);

  els.addQuestionBtn.onclick = ()=>{
    cfgDraft.questions.push(makeEmptyQuestion());
    renderQuestions();
    scheduleAutoPreview();
  };
  els.resetQuestionsBtn.onclick = ()=>{
    cfgDraft = deepClone(DEFAULT_CFG);
    cfgToUI();
    renderQuestions();
    els.codeBox.value = "";
    scheduleAutoPreview();
  };

  els.genIframeBtn.onclick = ()=>{
    readUIIntoDraft();
    const src = buildPlayUrlForIframe(cfgDraft);
    els.codeBox.value =
`<iframe src="${src}"
        style="width:100%;height:650px;border:0;background:transparent"
        width="100%" height="650"></iframe>`;
  };
  els.copyIframeBtn.onclick = async ()=>{
    const text = els.codeBox.value.trim();
    if(!text) return;
    try{
      await navigator.clipboard.writeText(text);
      els.copyIframeBtn.textContent = "–°–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ!";
      setTimeout(()=>els.copyIframeBtn.textContent="–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å", 900);
    }catch(e){
      els.copyIframeBtn.textContent = "–ù–µ —É–¥–∞–ª–æ—Å—å";
      setTimeout(()=>els.copyIframeBtn.textContent="–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å", 900);
    }
  };

  // init
  cfgToUI();
  renderQuestions();
  scheduleAutoPreview();
}

/* ================= GAME ================= */
function normalizeCfg(cfg){
  const out = deepClone(DEFAULT_CFG);

  Object.assign(out, cfg || {});

  // deep merge difficulty
  out.difficulty = deepClone(DEFAULT_CFG.difficulty);
  if(cfg && cfg.difficulty){
    for(const k of ["easy","medium","hard"]){
      if(cfg.difficulty[k]){
        out.difficulty[k] = Object.assign({}, out.difficulty[k], cfg.difficulty[k]);
      }
    }
  }

  // clamps
  out.questionSize = clampInt(out.questionSize, 12, 70, 24);
  out.scoreSize = clampInt(out.scoreSize, 12, 70, 24);
  out.livesSize = clampInt(out.livesSize, 12, 70, 24);
  out.progressHeight = clampInt(out.progressHeight, 14, 70, 30);

  out.bgSpeed = clampInt(out.bgSpeed, 0, 240, 90);
  out.bgSizeMode = ["auto","cover","contain"].includes(out.bgSizeMode) ? out.bgSizeMode : "auto";

  out.playerSize = clampInt(out.playerSize, 32, 240, 86);
  out.playerShadowStrength = clampInt(out.playerShadowStrength, 0, 40, 18);

  out.answerSize = clampInt(out.answerSize, 42, 260, 86);
  out.answerContentScale = clampNum(out.answerContentScale, 0.6, 2, 1);
  out.answerTextX = clampNum(out.answerTextX, 0, 100, 50);
  out.answerTextY = clampNum(out.answerTextY, 0, 100, 64);

  out.answerCardFit = (out.answerCardFit === "cover") ? "cover" : "contain";
  out.answerCardScale = clampNum(out.answerCardScale, 0.6, 2, 1);
  out.answerCardPosX = clampNum(out.answerCardPosX, 0, 100, 50);
  out.answerCardPosY = clampNum(out.answerCardPosY, 0, 100, 50);

  out.livesCount = clampInt(out.livesCount, 1, 10, 3);
  out.pointsPerCorrect = clampInt(out.pointsPerCorrect, 1, 200, 10);
  out.cooldownTurns = clampInt(out.cooldownTurns, 0, 10, 3);
  out.playerSpeed = clampInt(out.playerSpeed, 2, 18, 7);

  const clampLevel = (lv, defLv)=>{
    const r = Object.assign({}, defLv, lv||{});
    r.speed = clampNum(r.speed, 0.8, 8, defLv.speed);
    r.spawnEveryMs = clampInt(r.spawnEveryMs, 350, 2200, defLv.spawnEveryMs);
    r.minXGap = clampInt(r.minXGap, 120, 520, defLv.minXGap);
    r.maxOnScreen = clampInt(r.maxOnScreen, 1, 10, defLv.maxOnScreen);
    return r;
  };
  out.difficulty.easy = clampLevel(out.difficulty.easy, DEFAULT_CFG.difficulty.easy);
  out.difficulty.medium = clampLevel(out.difficulty.medium, DEFAULT_CFG.difficulty.medium);
  out.difficulty.hard = clampLevel(out.difficulty.hard, DEFAULT_CFG.difficulty.hard);

  // questions normalize
  if(!Array.isArray(out.questions) || out.questions.length === 0) out.questions = deepClone(DEFAULT_CFG.questions);
  out.questions = out.questions.map(q=>{
    const qq = { q: String(q.q||""), answers: Array.isArray(q.answers)?q.answers:[] };
    qq.answers = qq.answers.map(a=>({label:String(a.label||""), text:String(a.text||""), correct:!!a.correct}));
    if(qq.answers.length < 2) qq.answers = [{label:"A", text:"", correct:true},{label:"B", text:"", correct:false}];
    if(!qq.answers.some(a=>a.correct)) qq.answers[0].correct = true;
    return qq;
  });

  out.lives = out.livesCount;
  return out;
}

function startGameMode(){
  const root = document.getElementById("gameRoot");

  let cfg = deepClone(DEFAULT_CFG);
  const cfgParam = params.get("cfg");
  if(cfgParam){
    try{ cfg = Object.assign(cfg, JSON.parse(b64urlDecode(cfgParam))); }catch(e){}
  }
  const CFG = normalizeCfg(cfg);

  root.innerHTML = `
  <style>
    html,body{margin:0;height:100%;background:transparent!important;overflow:hidden;touch-action:none;}
    #wrap{position:relative;width:100%;height:100%;background:transparent;}

    /* ===== background (seamless repeat-x) ===== */
    #bg{
      position:absolute; inset:0; z-index:0;
      overflow:hidden;
      background: ${CFG.transparentBg ? "transparent" : "rgba(0,0,0,.18)"};
    }
    .bgLayer{
      position:absolute; inset:0;
      background-image: ${(!CFG.transparentBg && CFG.bgImg) ? `url('${cssUrl(CFG.bgImg)}')` : "none"};
      background-repeat: repeat-x;
      background-position: 0 50%;
      background-size: ${
        CFG.bgSizeMode === "cover" ? "cover" :
        CFG.bgSizeMode === "contain" ? "contain" :
        "auto 100%"
      };
      transform: translate3d(0,0,0);
      will-change: background-position;
      opacity: ${(!CFG.transparentBg && CFG.bgImg) ? 1 : 0};
    }

    #game{position:absolute; inset:0; z-index:2; font-family:${escapeCss(CFG.fontFamily)};}
    #scene{position:absolute; inset:0; overflow:hidden; z-index:3;}

    #topbar{
      position:absolute; top:14px; left:14px; right:14px;
      display:flex; align-items:flex-start; justify-content:space-between;
      gap:12px; z-index:120; pointer-events:none;
    }
    .pill{
      background: ${hexToRgba(CFG.hudPanelColor, 0.70)};
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 999px;
      padding: 14px 16px;
      box-shadow: 0 16px 60px rgba(0,0,0,.42);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display:flex; gap:12px; align-items:center;
      white-space:nowrap;
      color: ${CFG.hudTextColor};
      font-weight:${CFG.fontWeight};
      pointer-events:none;
    }
    .pill .label{font-size:14px;color:${hexToRgba(CFG.hudTextColor, 0.75)};}
    .pill .value{font-size:${CFG.scoreSize}px;}
    #lives{font-size:${CFG.livesSize}px;letter-spacing:1px;color:${CFG.hudTextColor};}

    #questionWrap{
      position:absolute; top:78px; left:50%; transform:translateX(-50%);
      z-index:110; pointer-events:none;
      max-width:min(980px, calc(100% - 28px));
    }
    #questionBox{
      background: ${hexToRgba(CFG.questionBgColor, 0.62)};
      border: 1px solid ${hexToRgba(CFG.questionBorderColor, 0.55)};
      border-radius: 999px;
      padding: 16px 20px;
      box-shadow: 0 16px 60px rgba(0,0,0,.42);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      text-align:center;
      font-weight:${CFG.fontWeight};
      font-size:${CFG.questionSize}px;
      color: ${CFG.questionColor};
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }

    /* ===== player ===== */
    #player{
      position:absolute;
      left:92px;
      top:50%;
      width:${CFG.playerSize}px;
      height:${CFG.playerSize}px;
      transform: translate(-50%,-50%);
      background: transparent;
      pointer-events:none;
      will-change: transform, top;
    }
    #playerImg{
      position:absolute; inset:0;
      background: ${CFG.playerImg ? `url('${cssUrl(CFG.playerImg)}') center/contain no-repeat` : "none"};
      filter: ${CFG.playerShadowOn ? `drop-shadow(0 0 ${Math.max(0, CFG.playerShadowStrength)}px ${hexToRgba(CFG.playerShadowColor, 0.85)})` : "none"};
      transform: translate3d(0,0,0);
      will-change: transform;
    }
    /* –ø–∞—Ä–µ–Ω–∏–µ */
    @keyframes hoverBob {
      0%{transform: translateY(0);}
      50%{transform: translateY(-6px);}
      100%{transform: translateY(0);}
    }
    #playerImg.bob{
      animation: hoverBob 1.2s ease-in-out infinite;
    }
    /* –ª—ë–≥–∫–æ–µ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ –ø—Ä–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ–ø–∞–¥–∞–Ω–∏–∏ */
    @keyframes playerBoost{
      0%{transform: scale(1);}
      35%{transform: scale(1.08);}
      100%{transform: scale(1);}
    }
    #playerImg.boost{ animation: playerBoost .22s ease-out; }

    /* ===== answers (no panel background) ===== */
    .answer{
      position:absolute;
      width:${CFG.answerSize}px;
      height:${CFG.answerSize}px;
      transform: translate(-50%,-50%);
      user-select:none;
      pointer-events:none;
      background: transparent;
      overflow: visible;
      will-change: transform, left;
    }
    .answer .bg{
      position:absolute; inset:0;
      background-image: ${CFG.answerCardImg ? `url('${cssUrl(CFG.answerCardImg)}')` : "none"};
      background-repeat:no-repeat;
      background-size:${CFG.answerCardFit};
      background-position:${CFG.answerCardPosX}% ${CFG.answerCardPosY}%;
      transform: scale(${CFG.answerCardScale});
      transform-origin:center;
      will-change: transform;
    }
    .answer .txt{
      position:absolute;
      left:${CFG.answerTextX}%;
      top:${CFG.answerTextY}%;
      transform: translate(-50%,-50%) scale(${CFG.answerContentScale});
      text-align:center;
      color: rgba(255,255,255,.95);
      font-weight:${CFG.fontWeight};
      font-size: 14px;
      line-height:1.15;
      max-width: 220px;
      white-space:normal;
      word-break:break-word;
      padding: ${CFG.answerTextBgOn ? "6px 10px" : "0"};
      border-radius: 10px;
      border: ${CFG.answerTextBgOn ? "1px solid rgba(255,255,255,.10)" : "0"};
      background: ${CFG.answerTextBgOn ? "rgba(0,0,0,.22)" : "transparent"};
      text-shadow: 0 10px 22px rgba(0,0,0,.55);
    }
    /* –º–∏–≥–∞–Ω–∏–µ –ø—Ä–∏ –æ—à–∏–±–∫–µ */
    @keyframes flashBad{
      0%,100%{filter:none; opacity:1;}
      20%{filter: drop-shadow(0 0 10px rgba(255,80,80,.95)); opacity:.55;}
      40%{opacity:1;}
      60%{filter: drop-shadow(0 0 10px rgba(255,80,80,.95)); opacity:.55;}
      80%{opacity:1;}
    }
    .answer.flash{ animation: flashBad .28s ease-in-out; }

    /* ===== feedback (short) ===== */
    #feedback{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      font-size:34px;font-weight:${CFG.fontWeight};
      pointer-events:none;
      opacity:0; transition:.18s;
      z-index:130;
      text-shadow: 0 16px 36px rgba(0,0,0,.55);
      color: rgba(255,255,255,.92);
    }
    #feedback.show{opacity:1;}

    /* ===== progress ===== */
    #progressWrap{
      position:absolute; left:14px; right:14px; bottom:14px;
      z-index:115; pointer-events:none;
    }
    #progressBar{
      height: ${CFG.progressHeight}px;
      border-radius: 999px;
      background: rgba(0,0,0,.14);
      border: 1px solid rgba(255,255,255,.22);
      box-shadow: 0 16px 60px rgba(0,0,0,.42);
      overflow:hidden;
      position:relative;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #progressFill{
      height:100%; width:0%;
      background: ${CFG.progressColor};
      border-radius:999px;
      transition: width .25s ease;
    }
    #progressText{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      font-size:14px; font-weight:${CFG.fontWeight};
      color: rgba(255,255,255,.96);
      text-shadow:0 10px 22px rgba(0,0,0,.5);
    }

    /* ===== overlays ===== */
    .overlay{
      position:absolute; inset:0;
      display:none;
      align-items:center; justify-content:center;
      z-index:300;
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      pointer-events:auto;
    }
    .overlay.show{display:flex;}
    .cardModal{
      width:min(640px, calc(100% - 28px));
      background: rgba(20,18,34,.78);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 22px;
      box-shadow: 0 16px 60px rgba(0,0,0,.42);
      padding: 18px 18px 16px;
      color: rgba(255,255,255,.92);
    }
    .cardModal h2{margin:0 0 8px;font-size:22px;font-weight:${CFG.fontWeight};display:flex;gap:10px;align-items:center;}
    .cardModal p{margin:0 0 12px;font-size:14px;line-height:1.35;opacity:.9;}
    .row2{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;}
    .chips{display:flex;gap:8px;flex-wrap:wrap;}
    .chipBtn{
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.18);
      border-radius: 999px;
      padding: 10px 14px;
      font-weight:${CFG.fontWeight};
      font-size:13px;
      color: rgba(255,255,255,.92);
      cursor:pointer;
      user-select:none;
    }
    .chipBtn.active{
      background: ${hexToRgba(CFG.btnColor, 0.30)};
      border-color: ${hexToRgba(CFG.btnColor, 0.55)};
    }
    .btn2{
      background: ${hexToRgba(CFG.btnColor, 0.55)};
      border: 1px solid ${hexToRgba(CFG.btnColor, 0.70)};
      border-radius: 14px;
      padding: 12px 16px;
      font-weight:${CFG.fontWeight};
      color: ${CFG.btnTextColor};
      cursor:pointer;
      user-select:none;
      white-space:nowrap;
      font-size:14px;
    }
    .iconDot{
      width:34px;height:34px;border-radius:999px;
      border:1px solid ${hexToRgba(CFG.iconColor,0.65)};
      background:${hexToRgba(CFG.iconColor,0.20)};
      box-shadow: 0 0 22px ${hexToRgba(CFG.iconColor,0.35)};
      display:inline-flex; align-items:center; justify-content:center;
      font-size:18px; color:${CFG.iconColor};
    }

    /* ===== lose tint ===== */
    #loseTint{
      position:absolute; inset:0; z-index:500;
      pointer-events:none;
      background: rgba(255,0,0,.12);
      opacity:0;
      transition: opacity .35s ease;
    }
    #loseTint.show{ opacity:1; }

    /* ===== fireworks ===== */
    #fxLayer{
      position:absolute; inset:0; z-index:520;
      pointer-events:none;
      overflow:hidden;
    }
    .confetti{
      position:absolute;
      width:10px;height:18px;
      opacity:0.95;
      transform: translate3d(0,0,0) rotate(0deg);
      will-change: transform, opacity;
      animation: confettiFall 1.35s ease-out forwards;
    }
    @keyframes confettiFall{
      0%{ transform: translate3d(var(--sx), var(--sy), 0) rotate(0deg); opacity:1; }
      100%{ transform: translate3d(var(--ex), var(--ey), 0) rotate(520deg); opacity:0; }
    }

    /* prevent selection */
    *{ -webkit-tap-highlight-color: transparent; }
  </style>

  <div id="wrap">
    <div id="bg">
      <div class="bgLayer" id="bgLayer"></div>
    </div>

    <div id="game">
      <div id="topbar">
        <div class="pill"><div class="label">–û—á–∫–∏</div><div class="value" id="score">0</div></div>
        <div class="pill" id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
      </div>

      <div id="questionWrap"><div id="questionBox">‚Äî</div></div>

      <div id="scene">
        <div id="player"><div id="playerImg" class="bob"></div></div>
      </div>

      <div id="feedback"></div>

      <div id="progressWrap">
        <div id="progressBar">
          <div id="progressFill"></div>
          <div id="progressText">–í–æ–ø—Ä–æ—Å 1 –∏–∑ 1</div>
        </div>
      </div>

      <div id="startOverlay" class="overlay show">
        <div class="cardModal">
          <h2><span class="iconDot">‚ñ∂</span> –í—ã–±–µ—Ä–∏ —Å–ª–æ–∂–Ω–æ—Å—Ç—å</h2>
          <p>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: <b>‚Üë/‚Üì</b> –∏–ª–∏ <b>—Å–µ–Ω—Å–æ—Ä</b> ‚Äî –≤–µ–¥–∏ –ø–∞–ª—å—Ü–µ–º –ø–æ —ç–∫—Ä–∞–Ω—É.</p>
          <div class="row2">
            <div class="chips">
              <div class="chipBtn active" data-level="easy">–õ—ë–≥–∫–∏–π</div>
              <div class="chipBtn" data-level="medium">–°—Ä–µ–¥–Ω–∏–π</div>
              <div class="chipBtn" data-level="hard">–°–ª–æ–∂–Ω—ã–π</div>
            </div>
            <button class="btn2" id="startBtn">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
          </div>
        </div>
      </div>

      <div id="finalOverlay" class="overlay">
        <div class="cardModal">
          <h2 id="finalTitle"><span class="iconDot">‚òÖ</span> ‚Äî</h2>
          <p id="finalText">‚Äî</p>
          <div class="row2" style="justify-content:flex-end;">
            <button class="btn2" id="playAgainBtn">–ò–≥—Ä–∞—Ç—å –µ—â—ë</button>
          </div>
        </div>
      </div>

      <div id="loseTint"></div>
      <div id="fxLayer"></div>
    </div>
  </div>
  `;

  // elements
  const bgLayer = root.querySelector("#bgLayer");
  const scene = root.querySelector("#scene");
  const player = root.querySelector("#player");
  const playerImg = root.querySelector("#playerImg");

  const questionBox = root.querySelector("#questionBox");
  const scoreEl = root.querySelector("#score");
  const livesEl = root.querySelector("#lives");

  const feedback = root.querySelector("#feedback");
  const progressFill = root.querySelector("#progressFill");
  const progressText = root.querySelector("#progressText");

  const startOverlay = root.querySelector("#startOverlay");
  const startBtn = root.querySelector("#startBtn");
  const diffBtns = Array.from(root.querySelectorAll(".chipBtn"));

  const finalOverlay = root.querySelector("#finalOverlay");
  const finalTitle = root.querySelector("#finalTitle");
  const finalText = root.querySelector("#finalText");
  const playAgainBtn = root.querySelector("#playAgainBtn");

  const loseTint = root.querySelector("#loseTint");
  const fxLayer = root.querySelector("#fxLayer");

  // apply player img
  if(CFG.playerImg){
    playerImg.style.backgroundImage = `url('${cssUrl(CFG.playerImg)}')`;
  }

  // ===== state
  let keys = {};
  let state = null;
  let pendingTimer = null;

  // touch control
  let touchActive = false;
  let targetY = null;

  // bg animation
  let bgOffset = 0;

  function clearPending(){ if(pendingTimer!==null){ clearTimeout(pendingTimer); pendingTimer=null; } }
  function showOverlay(el, on){ if(on) el.classList.add("show"); else el.classList.remove("show"); }
  function preset(level){ return CFG.difficulty[level] || CFG.difficulty.easy; }
  function hearts(n){ return "‚ù§Ô∏è".repeat(Math.max(0,n)) + (n<=0 ? "‚Äî" : ""); }

  function initState(){
    state = {
      phase:"menu",
      locked:true,
      score:0,
      lives:CFG.livesCount,
      remaining: CFG.questions.map((_,i)=>i),
      currentIdx:null,
      recent:[],
      active:[],
      lastSpawnAt: performance.now(),
      lastLaneY: null,

      difficulty:"easy",
      speed:preset("easy").speed,
      spawnEveryMs:preset("easy").spawnEveryMs,
      minXGap:preset("easy").minXGap,
      maxOnScreen:preset("easy").maxOnScreen,

      playerY: scene.clientHeight * 0.5,
      playerV: 0,          // –¥–ª—è –Ω–∞–∫–ª–æ–Ω–∞
      tiltDeg: 0,
    };
  }

  function applyDifficulty(level){
    const p = preset(level);
    state.difficulty = level;
    state.speed = p.speed;
    state.spawnEveryMs = p.spawnEveryMs;
    state.minXGap = p.minXGap;
    state.maxOnScreen = p.maxOnScreen;
    diffBtns.forEach(b=>b.classList.toggle("active", b.dataset.level===level));
  }

  function updateProgress(){
    const total = CFG.questions.length;
    const done = total - state.remaining.length;
    const current = Math.min(done + 1, total);
    const pct = total ? Math.round((done / total) * 100) : 0;
    progressFill.style.width = pct + "%";
    progressText.textContent = `–í–æ–ø—Ä–æ—Å ${current} –∏–∑ ${total}`;
  }

  function updateHUD(){
    scoreEl.textContent = String(state.score);
    livesEl.textContent = hearts(state.lives);
    const q = (state.currentIdx!==null) ? CFG.questions[state.currentIdx] : null;
    questionBox.textContent = q ? q.q : "";
    updateProgress();
  }

  function clearAnswers(){
    state.active.forEach(o=>o.el.remove());
    state.active = [];
    state.lastLaneY = null;
  }

  function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }

  function buildLanes(){
    const minY = 150;
    const maxY = scene.clientHeight - 110;
    const step = Math.max(86, CFG.answerSize + 10);
    const lanes=[];
    for(let y=minY; y<=maxY; y+=step) lanes.push(y);
    return lanes.length ? lanes : [Math.round((minY+maxY)/2)];
  }

  function pickLaneY(){
    const lanes = buildLanes();
    let y = lanes[randInt(0, lanes.length-1)];
    if(state.lastLaneY!==null && lanes.length>1){
      let tries=0;
      while(y===state.lastLaneY && tries<10){
        y = lanes[randInt(0, lanes.length-1)];
        tries++;
      }
    }
    state.lastLaneY = y;
    return y;
  }

  function createAnswerOrb(answer){
    const el = document.createElement("div");
    el.className = "answer";
    el.dataset.correct = answer.correct ? "1" : "0";

    const bg = document.createElement("div");
    bg.className = "bg";
    el.appendChild(bg);

    const txt = document.createElement("div");
    txt.className = "txt";
    txt.textContent = answer.text || "";
    el.appendChild(txt);

    return el;
  }

  function rightEdgeX(){ return scene.clientWidth + 80; }
  function newestX(){
    let maxX = -Infinity;
    for(const o of state.active) maxX = Math.max(maxX, o.el.offsetLeft);
    return maxX;
  }

  function maybeSpawn(now){
    if(state.phase!=="playing" || state.locked) return;
    if(state.active.length >= state.maxOnScreen) return;
    if(now - state.lastSpawnAt < state.spawnEveryMs) return;

    const spawnX = rightEdgeX();
    const nx = newestX();
    if(nx!==-Infinity && nx > (spawnX - state.minXGap)) return;

    const q = (state.currentIdx!==null) ? CFG.questions[state.currentIdx] : null;
    if(!q) return;

    const pick = q.answers[randInt(0, q.answers.length-1)];
    const el = createAnswerOrb(pick);

    el.style.left = spawnX + "px";
    el.style.top = pickLaneY() + "px";
    el.style.width = CFG.answerSize + "px";
    el.style.height = CFG.answerSize + "px";

    scene.appendChild(el);
    state.active.push({ el, data: pick, hit:false });
    state.lastSpawnAt = now;
  }

  function showFeedback(text, ok){
    feedback.textContent = text;
    feedback.style.color = ok ? "#4cff9e" : "#ff6b6b";
    feedback.classList.add("show");
    setTimeout(()=>feedback.classList.remove("show"), 340);
  }

  function fireConfettiBurst(){
    // –º–∞–ª–µ–Ω—å–∫–∏–π —Å–∞–ª—é—Ç: –Ω–µ—Å–∫–æ–ª—å–∫–æ –∫–æ–Ω—Ñ–µ—Ç—Ç–∏ –∏–∑ —Ü–µ–Ω—Ç—Ä–∞
    const cx = scene.clientWidth * 0.55;
    const cy = scene.clientHeight * 0.35;
    const n = 70;
    for(let i=0;i<n;i++){
      const d = document.createElement("div");
      d.className = "confetti";
      const ang = Math.random()*Math.PI*2;
      const dist = 220 + Math.random()*260;
      const ex = Math.cos(ang) * dist;
      const ey = Math.sin(ang) * dist + 260;

      const sx = (cx + (Math.random()*30-15)) + "px";
      const sy = (cy + (Math.random()*30-15)) + "px";
      const endX = (cx + ex) + "px";
      const endY = (cy + ey) + "px";

      d.style.left = "0px";
      d.style.top = "0px";
      d.style.setProperty("--sx", sx);
      d.style.setProperty("--sy", sy);
      d.style.setProperty("--ex", endX);
      d.style.setProperty("--ey", endY);

      // —Å–ª—É—á–∞–π–Ω—ã–π —Ü–≤–µ—Ç
      const colors = ["#ffd84a","#7a5aff","#4cff9e","#ff6b6b","#ffffff"];
      d.style.background = colors[Math.floor(Math.random()*colors.length)];
      d.style.borderRadius = (Math.random()>0.5) ? "4px" : "999px";

      fxLayer.appendChild(d);
      setTimeout(()=>d.remove(), 1500);
    }
  }

  function endGame(win){
    clearPending();
    state.phase="ended";
    state.locked=true;
    clearAnswers();
    updateHUD();

    if(win){
      fireConfettiBurst();
    }else{
      loseTint.classList.add("show");
    }

    finalTitle.innerHTML = win
      ? `<span class="iconDot">üèÜ</span> –ü–æ–±–µ–¥–∞!`
      : `<span class="iconDot">‚ü≤</span> –ü–æ—Ä–∞–∂–µ–Ω–∏–µ`;

    finalText.textContent = win
      ? (CFG.finalWinText?.trim() || `–¢—ã –ø–æ–±–µ–¥–∏–ª(–∞)! –û—á–∫–∏: ${state.score}.`)
      : (CFG.finalLoseText?.trim() || `–ñ–∏–∑–Ω–∏ –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å. –û—á–∫–∏: ${state.score}.`);

    showOverlay(finalOverlay, true);
  }

  function pushRecent(idx){
    if(idx===null) return;
    state.recent.push(idx);
    const maxLen = Math.max(0, CFG.cooldownTurns + 1);
    while(state.recent.length > maxLen) state.recent.shift();
  }

  function pickNextQuestionWithCooldown(){
    if(!state.remaining.length) return null;
    if(state.remaining.length===1) return state.remaining[0];
    const banned = new Set(state.recent);
    const candidates = state.remaining.filter(i => !banned.has(i));
    let pool = candidates.length ? candidates : state.remaining.filter(i => i!==state.currentIdx);
    if(!pool.length) pool = state.remaining.slice();
    return pool[Math.floor(Math.random() * pool.length)];
  }

  function chooseNextQuestion(){
    pushRecent(state.currentIdx);
    state.currentIdx = pickNextQuestionWithCooldown();
    if(state.currentIdx===null){ endGame(true); return; }
    updateHUD();
    state.locked=false;
    clearAnswers();
    state.lastSpawnAt = performance.now();
  }

  function handleHit(correct, hitObj){
    if(state.locked || state.phase!=="playing") return;
    state.locked = true;
    clearPending();

    if(correct){
      // player boost
      playerImg.classList.remove("boost");
      void playerImg.offsetWidth;
      playerImg.classList.add("boost");

      state.score += CFG.pointsPerCorrect;
      showFeedback(CFG.hitOkText || "–í–µ—Ä–Ω–æ!", true);

      const idx = state.currentIdx;
      state.remaining = state.remaining.filter(x => x!==idx);

      // —É–±—Ä–∞—Ç—å –æ–±—ä–µ–∫—Ç —Å—Ä–∞–∑—É
      hitObj?.el?.remove?.();

      pendingTimer = setTimeout(()=>{
        pendingTimer=null;
        state.remaining.length===0 ? endGame(true) : chooseNextQuestion();
      }, 420);
    }else{
      state.lives--;
      showFeedback(CFG.hitBadText || "–ù–µ–≤–µ—Ä–Ω–æ!", false);

      // –º–∏–≥–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–∞ (–µ—Å–ª–∏ –µ—Å—Ç—å)
      if(hitObj?.el && hitObj.el.isConnected){
        hitObj.el.classList.add("flash");
        setTimeout(()=>hitObj.el?.remove?.(), 220);
      }

      pendingTimer = setTimeout(()=>{
        pendingTimer=null;
        state.lives<=0 ? endGame(false) : chooseNextQuestion();
      }, 520);
    }

    // –æ—á–∏—Å—Ç–∏–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ, —á—Ç–æ–±—ã –Ω–µ –º–µ—à–∞–ª–∏
    state.active.forEach(o=>{
      if(o !== hitObj && o.el?.isConnected) o.el.remove();
    });
    state.active = [];
    updateHUD();
  }

  function checkCollision(obj){
    if(obj.hit || state.locked || state.phase!=="playing") return;
    const a = obj.el.getBoundingClientRect();
    const p = player.getBoundingClientRect();
    const overlap = !(a.right<p.left || a.left>p.right || a.bottom<p.top || a.top>p.bottom);
    if(overlap){
      obj.hit = true;
      handleHit(obj.data.correct===true, obj);
    }
  }

  function resetGameForPlay(){
    clearPending();
    loseTint.classList.remove("show");
    fxLayer.innerHTML = "";

    clearAnswers();
    state.score=0;
    state.lives=CFG.livesCount;
    state.remaining = CFG.questions.map((_,i)=>i);
    state.recent=[];
    state.phase="playing";
    state.locked=false;

    state.currentIdx = pickNextQuestionWithCooldown();
    state.lastSpawnAt = performance.now();

    state.playerY = scene.clientHeight * 0.5;
    state.playerV = 0;
    state.tiltDeg = 0;

    player.style.top = state.playerY + "px";
    updateHUD();
  }

  async function startGame(){
    showOverlay(startOverlay,false);
    showOverlay(finalOverlay,false);
    resetGameForPlay();
  }
  async function playAgain(){
    showOverlay(finalOverlay,false);
    showOverlay(startOverlay,false);
    resetGameForPlay();
  }

  // ===== background loop =====
  function updateBg(dt){
    if(CFG.transparentBg || !CFG.bgImg || CFG.bgSpeed<=0) return;
    bgOffset += (CFG.bgSpeed * dt) / 1000;
    // repeat-x, –¥–≤–∏–≥–∞–µ–º background-position
    bgLayer.style.backgroundPosition = (-bgOffset) + "px 50%";
  }

  // ===== player movement + tilt =====
  function updatePlayer(dt){
    if(state.phase!=="playing") return;

    const h = scene.clientHeight;
    const half = CFG.playerSize * 0.5;

    let y = state.playerY;
    let v = state.playerV;

    // keyboard control -> acceleration-like
    let dir = 0;
    if(keys.ArrowUp) dir -= 1;
    if(keys.ArrowDown) dir += 1;

    if(touchActive && typeof targetY === "number"){
      // –ø–ª–∞–≤–Ω–æ –∫ targetY (—Å–µ–Ω—Å–æ—Ä)
      const diff = (targetY - y);
      const step = diff * Math.min(1, dt/120);
      v = step; // –¥–ª—è –Ω–∞–∫–ª–æ–Ω–∞
      y += step;
    }else if(dir !== 0){
      const sp = CFG.playerSpeed;
      v = dir * sp;
      y += v;
    }else{
      // –∑–∞—Ç—É—Ö–∞–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏
      v *= 0.85;
    }

    y = Math.max(half, Math.min(h - half, y));
    state.playerY = y;
    state.playerV = v;

    // tilt: –≤–Ω–∏–∑ -> –Ω–∞–∫–ª–æ–Ω –≤–Ω–∏–∑, –≤–≤–µ—Ä—Ö -> –≤–≤–µ—Ä—Ö
    const targetTilt = clampNum(v * 2.2, -18, 18, 0);
    state.tiltDeg += (targetTilt - state.tiltDeg) * Math.min(1, dt/110);

    player.style.top = y + "px";
    player.style.transform = `translate(-50%,-50%) rotate(${state.tiltDeg}deg)`;
  }

  function loop(now){
    const dt = state._lastNow ? (now - state._lastNow) : 16;
    state._lastNow = now;

    updateBg(dt);

    if(state.phase==="playing"){
      updatePlayer(dt);

      maybeSpawn(now);

      if(!state.locked){
        const leftLimit = -200;
        const next=[];
        for(const obj of state.active){
          obj.el.style.left = (obj.el.offsetLeft - state.speed) + "px";
          checkCollision(obj);

          if(obj.el.isConnected){
            if(obj.el.offsetLeft >= leftLimit) next.push(obj);
            else obj.el.remove();
          }
        }
        state.active = next;
      }
    }

    requestAnimationFrame(loop);
  }

  // ===== input =====
  diffBtns.forEach(btn=>{
    btn.addEventListener("click", ()=>{
      applyDifficulty(btn.dataset.level);
    });
  });
  startBtn.addEventListener("click", startGame);
  playAgainBtn.addEventListener("click", playAgain);

  window.addEventListener("keydown",(e)=>{ keys[e.key]=true; }, {passive:true});
  window.addEventListener("keyup",(e)=>{ keys[e.key]=false; }, {passive:true});

  // —Å–µ–Ω—Å–æ—Ä: –≤–µ–¥—ë–º –ø–∞–ª—å—Ü–µ–º –ø–æ —ç–∫—Ä–∞–Ω—É
  function onPointerDown(e){
    if(state.phase!=="playing") return;
    touchActive = true;
    const r = scene.getBoundingClientRect();
    targetY = e.clientY - r.top;
  }
  function onPointerMove(e){
    if(!touchActive) return;
    const r = scene.getBoundingClientRect();
    targetY = e.clientY - r.top;
  }
  function onPointerUp(){
    touchActive = false;
    targetY = null;
  }
  window.addEventListener("pointerdown", onPointerDown, {passive:true});
  window.addEventListener("pointermove", onPointerMove, {passive:true});
  window.addEventListener("pointerup", onPointerUp, {passive:true});
  window.addEventListener("pointercancel", onPointerUp, {passive:true});

  // init
  initState();
  applyDifficulty("easy");
  updateHUD();
  player.style.top = "50%";
  showOverlay(startOverlay,true);
  showOverlay(finalOverlay,false);

  requestAnimationFrame(loop);
}
</script>
</body>
</html>
