<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Catch the Answer</title>
  <link rel="icon" href="data:,">

  <style>
    :root{
      --bg: transparent;

      --panel-bg: rgba(10,10,20,.60);
      --panel-brd: rgba(255,255,255,.18);
      --shadow: 0 16px 60px rgba(0,0,0,.42);

      /* –í–ê–ñ–ù–û: –æ—Ç–≤–µ—Ç—ã —Ç—ë–º–Ω—ã–µ => —Ç–µ–∫—Å—Ç —Ç–æ—á–Ω–æ –≤–∏–¥–µ–Ω –Ω–∞ –±–µ–ª–æ–º —Ñ–æ–Ω–µ */
      --answer-bg: rgba(20, 18, 34, .82);
      --answer-brd: rgba(255,255,255,.22);
      --answer-text: rgba(255,255,255,.98);

      --player-bg: rgba(120,90,255,.22);
      --player-brd: rgba(120,90,255,.40);

      --good: #4cff9e;
      --bad:  #ff6b6b;

      --neon-yellow: #ffd84a;

      --size: 86px; /* –∏–≥—Ä–æ–∫ –∏ –æ—Ç–≤–µ—Ç—ã –æ–¥–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞ */
    }

    html,body{
      margin:0;height:100%;
      background:var(--bg)!important;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      overflow:hidden;
    }
    #game{position:relative;width:100%;height:100%;}

    /* HUD */
    #hud{
      position:absolute; top:12px; left:12px; right:12px;
      display:flex; align-items:flex-start; justify-content:space-between;
      gap:12px; z-index:60; pointer-events:none;
    }
    .pill{
      background: var(--panel-bg);
      border: 1px solid var(--panel-brd);
      border-radius: 999px;
      padding: 10px 12px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      display:flex; gap:10px; align-items:center;
      white-space:nowrap;
      color: rgba(255,255,255,.92);
    }
    .pill .label{font-size:12px;color:rgba(255,255,255,.72);font-weight:900}
    .pill .value{font-size:16px;font-weight:1100}

    /* QUESTION */
    #questionWrap{
      position:absolute; top:12px; left:50%; transform:translateX(-50%);
      z-index:61; pointer-events:none;
      max-width:min(900px, calc(100% - 24px));
    }
    #questionBox{
      background: var(--panel-bg);
      border: 1px solid var(--panel-brd);
      border-radius: 999px;
      padding: 12px 16px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      text-align:center;
      font-weight:1100;
      font-size:14px;
      color: rgba(255,255,255,.92);
      white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
    }

    /* SCENE */
    #scene{position:absolute; inset:0; overflow:hidden;}

    .orb{
      position:absolute;
      width: var(--size);
      height: var(--size);
      border-radius: 50%;
      display:flex; align-items:center; justify-content:center;
      user-select:none;
    }

    #player{
      left:92px; top:50%;
      transform:translate(-50%,-50%);
      background: var(--player-bg);
      border: 1px solid var(--player-brd);
      box-shadow: 0 12px 40px rgba(0,0,0,.28), 0 0 26px rgba(120,90,255,.25);
    }
    #player:before{
      content:"";
      width:18px;height:18px;border-radius:999px;
      background: rgba(255,255,255,.88);
      box-shadow:0 0 14px rgba(255,255,255,.25);
    }

    /* ANSWERS */
    .answer{
      background: var(--answer-bg);
      border: 1px solid var(--answer-brd);
      box-shadow: 0 16px 55px rgba(0,0,0,.35);
      color: var(--answer-text);
      padding: 10px 10px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      gap:6px;
    }
    .answer .lab{
      font-weight:1200;
      font-size:18px;
      line-height:1;
      letter-spacing:.8px;
      opacity:.98;
      text-shadow: 0 10px 22px rgba(0,0,0,.55);
      -webkit-text-stroke: 0.35px rgba(0,0,0,.35);
    }
    /* –¢–µ–∫—Å—Ç –≤–∞—Ä–∏–∞–Ω—Ç–∞ ‚Äî –¥–µ–ª–∞–µ–º "–∫–∞–∫ –±–µ–π–¥–∂" —á—Ç–æ–±—ã —Ç–æ—á–Ω–æ –±—ã–ª –≤–∏–¥–µ–Ω */
    .answer .txt{
      font-weight:1100;
      font-size:13px;
      line-height:1.12;
      opacity:1;
      max-width: 180px;
      white-space:normal;
      word-break:break-word;

      padding: 4px 8px;
      border-radius: 10px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);

      text-shadow: 0 10px 22px rgba(0,0,0,.55);
      -webkit-text-stroke: 0.35px rgba(0,0,0,.35);
    }

    /* +points (–∂—ë–ª—Ç—ã–π –Ω–µ–æ–Ω) */
    .pop{
      position:absolute;
      font-weight:1300;
      font-size:20px;
      pointer-events:none;
      transform:translate(-50%,-50%);
      color: var(--neon-yellow);
      text-shadow:
        0 0 10px rgba(255,216,74,.90),
        0 0 24px rgba(255,216,74,.70),
        0 16px 36px rgba(0,0,0,.55);
      animation: popUp .78s ease-out forwards;
      z-index:80;
    }
    @keyframes popUp{
      0%{opacity:0;transform:translate(-50%,-50%) scale(.9);}
      15%{opacity:1;transform:translate(-50%,-62%) scale(1.05);}
      100%{opacity:0;transform:translate(-50%,-112%) scale(1);}
    }

    #feedback{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      font-size:30px; font-weight:1200;
      pointer-events:none;
      opacity:0; transition:.18s;
      z-index:70;
      text-shadow: 0 16px 36px rgba(0,0,0,.55);
      color: rgba(255,255,255,.92);
    }
    #feedback.show{opacity:1;}

    /* progress bottom */
    #progressWrap{
      position:absolute; left:12px; right:12px; bottom:12px;
      z-index:90; pointer-events:none;
    }
    #progressBar{
      height: 20px;
      border-radius: 999px;
      background: rgba(0,0,0,.14);
      border: 1px solid rgba(255,255,255,.22);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    #progressFill{
      height:100%;
      width:0%;
      background: rgba(120,90,255,.72);
      border-radius:999px;
      transition: width .25s ease;
    }
    #progressText{
      position:absolute; inset:0;
      display:flex; align-items:center; justify-content:center;
      font-size:12px; font-weight:1200;
      color: rgba(255,255,255,.96);
      text-shadow:0 10px 22px rgba(0,0,0,.5);
    }

    #final{
      position:absolute; inset:0;
      background: rgba(0,0,0,.78);
      display:none;
      align-items:center; justify-content:center;
      flex-direction:column; gap:14px;
      z-index:120; text-align:center; padding:20px;
      color: rgba(255,255,255,.92);
    }
    #final.show{display:flex;}
    #final h1{margin:0;font-size:30px;}
    #final .small{opacity:.85;max-width:560px;line-height:1.4;font-size:13px;}
    #final button{
      pointer-events:auto;
      padding:10px 16px;border-radius:14px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.10);
      color:rgba(255,255,255,.92);
      font-weight:1100;cursor:pointer;
    }

    #version{
      position:absolute; right:12px; bottom:40px;
      font-size:12px; opacity:.55; pointer-events:none; z-index:200;
      color: rgba(0,0,0,.35);
    }
  </style>
</head>

<body>
<div id="game">
  <div id="hud">
    <div class="pill"><div class="label">–û—á–∫–∏</div><div class="value" id="score">0</div></div>
    <div class="pill" id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
  </div>

  <div id="questionWrap"><div id="questionBox">‚Äî</div></div>

  <div id="scene">
    <div class="orb" id="player"></div>
  </div>

  <div id="feedback"></div>

  <div id="progressWrap">
    <div id="progressBar">
      <div id="progressFill"></div>
      <div id="progressText">–í–æ–ø—Ä–æ—Å 1 –∏–∑ 1</div>
    </div>
  </div>

  <div id="final">
    <h1 id="finalTitle">‚Äî</h1>
    <div class="small" id="finalText"></div>
    <button onclick="restart()">–ò–≥—Ä–∞—Ç—å –µ—â—ë</button>
  </div>

  <div id="version">v8</div>
</div>

<script>
const GAME_CONFIG = {
  lives: 3,
  speed: 3.0,
  playerSpeed: 7,
  feedbackMs: 420,

  scoring: { pointsPerCorrect: 10, popText: (pts)=>`+${pts}` },

  sound: { enabled:true, ok:{volume:0.25}, bad:{volume:0.30} },

  progress: { show:true, text:(cur,total)=>`–í–æ–ø—Ä–æ—Å ${cur} –∏–∑ ${total}` },

  // ‚úÖ –µ—Å–ª–∏ –æ—Ç–≤–µ—Ç—ã —É–ª–µ—Ç–µ–ª–∏ –∏ –∏–≥—Ä–æ–∫ –∏—Ö "–ø—Ä–æ–ø—É—Å—Ç–∏–ª" ‚Äî —ç—Ç–æ –æ—à–∏–±–∫–∞
  missCountsAsWrong: true,

  layout: {
    paddingTop: 96,
    paddingBottom: 86,
    minDistY: 96,
    startX: 180,
    xSpreadMin: 170,
    xSpreadMax: 260,
  },

  questions: [
    { q:"–°—Ç–æ–ª–∏—Ü–∞ –§—Ä–∞–Ω—Ü–∏–∏?", answers:[
      {label:"A", text:"–ü–∞—Ä–∏–∂",  correct:true},
      {label:"B", text:"–†–∏–º",    correct:false},
      {label:"C", text:"–ë–µ—Ä–ª–∏–Ω", correct:false},
    ]},
    { q:"2 + 2 = ?", answers:[
      {label:"A", text:"3", correct:false},
      {label:"B", text:"4", correct:true},
      {label:"C", text:"5", correct:false},
    ]},
    { q:"–ì–¥–µ –±–æ–ª—å—à–µ: 7 –∏–ª–∏ 9?", answers:[
      {label:"A", text:"7", correct:false},
      {label:"B", text:"9", correct:true},
      {label:"C", text:"—Ä–∞–≤–Ω—ã", correct:false},
    ]},
  ],
};

const scene = document.getElementById("scene");
const player = document.getElementById("player");
const questionBox = document.getElementById("questionBox");
const scoreEl = document.getElementById("score");
const livesEl = document.getElementById("lives");
const feedback = document.getElementById("feedback");
const progressFill = document.getElementById("progressFill");
const progressText = document.getElementById("progressText");
const final = document.getElementById("final");
const finalTitle = document.getElementById("finalTitle");
const finalText = document.getElementById("finalText");

let keys = {};
let raf = null;

let state = null;

/* ---------- SOUND (WebAudio) ---------- */
let audioCtx = null, audioUnlocked = false;
function ensureAudio(){
  if(!GAME_CONFIG.sound.enabled) return;
  if(audioCtx) return;
  const Ctx = window.AudioContext || window.webkitAudioContext;
  if(!Ctx) return;
  audioCtx = new Ctx();
}
async function unlockAudio(){
  if(!GAME_CONFIG.sound.enabled) return;
  ensureAudio();
  if(!audioCtx) return;
  if(audioCtx.state === "suspended") { try{ await audioCtx.resume(); }catch(e){} }
  audioUnlocked = true;
}
function beepOk(){
  if(!GAME_CONFIG.sound.enabled || !audioUnlocked || !audioCtx) return;
  const v = GAME_CONFIG.sound.ok.volume ?? 0.25;
  const now = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type="sine";
  o.frequency.setValueAtTime(660, now);
  o.frequency.exponentialRampToValueAtTime(990, now+0.12);
  g.gain.setValueAtTime(0.0001, now);
  g.gain.exponentialRampToValueAtTime(v, now+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, now+0.18);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(now); o.stop(now+0.2);
}
function beepBad(){
  if(!GAME_CONFIG.sound.enabled || !audioUnlocked || !audioCtx) return;
  const v = GAME_CONFIG.sound.bad.volume ?? 0.30;
  const now = audioCtx.currentTime;
  const o1 = audioCtx.createOscillator();
  const o2 = audioCtx.createOscillator();
  const g  = audioCtx.createGain();
  o1.type="square"; o2.type="sawtooth";
  o1.frequency.setValueAtTime(220, now);
  o2.frequency.setValueAtTime(170, now);
  g.gain.setValueAtTime(0.0001, now);
  g.gain.exponentialRampToValueAtTime(v, now+0.01);
  g.gain.exponentialRampToValueAtTime(0.0001, now+0.22);
  o1.connect(g); o2.connect(g); g.connect(audioCtx.destination);
  o1.start(now); o2.start(now);
  o1.stop(now+0.24); o2.stop(now+0.24);
}
/* ------------------------------------- */

function initState(){
  state = {
    qIndex: 0,
    lives: GAME_CONFIG.lives,
    score: 0,
    locked: false,

    // ‚úÖ –≤–∞–∂–Ω–æ: —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –¥—É–±–ª–µ–π
    setId: 0,
    active: [],

    // —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –≤—Ç–æ—Ä–æ–≥–æ loop()
    running: true,
  };
}

function hearts(n){ return "‚ù§Ô∏è".repeat(Math.max(0,n)) + (n<=0 ? "‚Äî" : ""); }

function updateProgress(){
  const total = GAME_CONFIG.questions.length;
  const current = Math.min(state.qIndex + 1, total);
  const pct = total ? Math.round(((current-1) / total) * 100) : 0;
  progressFill.style.width = pct + "%";
  progressText.textContent = `–í–æ–ø—Ä–æ—Å ${current} –∏–∑ ${total}`;
}

function updateHUD(){
  scoreEl.textContent = String(state.score);
  livesEl.textContent = hearts(state.lives);
  questionBox.textContent = state.qIndex < GAME_CONFIG.questions.length ? GAME_CONFIG.questions[state.qIndex].q : "";
  updateProgress();
}

function clearAnswers(){
  state.active.forEach(o=>o.el.remove());
  state.active = [];
}

function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }

function spawnAnswersForQuestion(){
  // ‚úÖ —Å—Ç–æ–ø: –µ—Å–ª–∏ —É–∂–µ –µ—Å—Ç—å –æ—Ç–≤–µ—Ç—ã ‚Äî –Ω–µ —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—É—é –ø–∞—á–∫—É
  if(state.active.length) return;

  const q = GAME_CONFIG.questions[state.qIndex];
  const L = GAME_CONFIG.layout;

  state.setId++;
  const mySetId = state.setId;

  const usedY = [];
  const startX = scene.clientWidth + L.startX;

  function pickY(){
    const minY = L.paddingTop;
    const maxY = scene.clientHeight - L.paddingBottom;
    for(let attempt=0; attempt<80; attempt++){
      const y = randInt(minY, maxY);
      if(usedY.every(prev => Math.abs(prev-y) >= L.minDistY)){
        usedY.push(y); return y;
      }
    }
    const fallback = randInt(minY, maxY);
    usedY.push(fallback);
    return fallback;
  }

  const shuffled = [...q.answers].sort(()=>Math.random()-0.5);

  shuffled.forEach((a,i)=>{
    const el = document.createElement("div");
    el.className = "orb answer";
    el.dataset.correct = a.correct ? "1":"0";
    el.dataset.setid = String(mySetId);

    const lab = document.createElement("div");
    lab.className = "lab";
    lab.textContent = a.label;

    const txt = document.createElement("div");
    txt.className = "txt";
    txt.textContent = a.text;  // ‚úÖ —Ç–µ–∫—Å—Ç –≤–∞—Ä–∏–∞–Ω—Ç–∞

    el.appendChild(lab);
    el.appendChild(txt);

    const xOffset = i * randInt(L.xSpreadMin, L.xSpreadMax);
    el.style.left = (startX + xOffset) + "px";
    el.style.top = pickY() + "px";
    el.style.transform = "translate(-50%,-50%)";

    scene.appendChild(el);
    state.active.push({ el, data:a, hit:false, setId: mySetId });
  });
}

function showFeedback(text, ok){
  feedback.textContent = text;
  feedback.style.color = ok ? "var(--good)" : "var(--bad)";
  feedback.classList.add("show");
  setTimeout(()=>feedback.classList.remove("show"), Math.max(120, GAME_CONFIG.feedbackMs - 80));
}

function showPointsPop(x,y,points){
  const pop = document.createElement("div");
  pop.className = "pop";
  pop.textContent = GAME_CONFIG.scoring.popText(points);
  pop.style.left = x + "px";
  pop.style.top = y + "px";
  scene.appendChild(pop);
  setTimeout(()=>pop.remove(), 900);
}

function endGame(win){
  state.locked = true;
  state.running = false;
  clearAnswers();
  updateHUD();
  final.classList.add("show");
  finalTitle.textContent = win ? "üéâ –û—Ç–ª–∏—á–Ω–æ!" : "üíÄ –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞";
  const total = GAME_CONFIG.questions.length;
  const answered = Math.min(state.qIndex, total);
  finalText.textContent = `–ü—Ä–æ–π–¥–µ–Ω–æ ${answered}/${total}. –û—á–∫–∏: ${state.score}.`;
  if(raf) cancelAnimationFrame(raf);
  raf = null;
}

function goNextQuestion(){
  state.qIndex++;
  state.locked = false;
  clearAnswers();

  if(state.lives <= 0){ endGame(false); return; }
  if(state.qIndex >= GAME_CONFIG.questions.length){ endGame(true); return; }

  updateHUD();
  spawnAnswersForQuestion();
}

function applyWrong(reasonText){
  state.lives--;
  updateHUD();
  showFeedback(reasonText || "–ù–µ–≤–µ—Ä–Ω–æ", false);
  beepBad();
  player.animate(
    [{transform:"translate(-50%,-50%)"},
     {transform:"translate(-50%,-50%) translateX(-4px)"},
     {transform:"translate(-50%,-50%) translateX(4px)"},
     {transform:"translate(-50%,-50%)"}],
    {duration:220}
  );
}

function handleAnswer(correct, hitX, hitY){
  if(state.locked) return;
  state.locked = true;

  // —É–±—Ä–∞—Ç—å –æ—Å—Ç–∞–ª—å–Ω—ã–µ, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –≤—Ç–æ—Ä–∏—á–Ω—ã—Ö –ø–æ–ø–∞–¥–∞–Ω–∏–π
  clearAnswers();

  if(correct){
    const pts = GAME_CONFIG.scoring.pointsPerCorrect;
    state.score += pts;
    updateHUD();
    showPointsPop(hitX, hitY, pts);
    showFeedback("–í–µ—Ä–Ω–æ", true);
    beepOk();
  }else{
    applyWrong("–ù–µ–≤–µ—Ä–Ω–æ");
  }

  setTimeout(goNextQuestion, GAME_CONFIG.feedbackMs);
}

function checkCollision(obj){
  if(obj.hit || state.locked) return;

  const a = obj.el.getBoundingClientRect();
  const p = player.getBoundingClientRect();
  const overlap = !(a.right<p.left || a.left>p.right || a.bottom<p.top || a.top>p.bottom);

  if(overlap){
    obj.hit = true;
    const sr = scene.getBoundingClientRect();
    const hitX = (a.left+a.right)/2 - sr.left;
    const hitY = (a.top+a.bottom)/2 - sr.top;

    obj.el.remove();
    handleAnswer(obj.data.correct===true, hitX, hitY);
  }
}

function loop(){
  if(!state || !state.running) return;

  // –¥–≤–∏–∂–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–∞
  let y = player.offsetTop;
  if(keys.ArrowUp) y -= GAME_CONFIG.playerSpeed;
  if(keys.ArrowDown) y += GAME_CONFIG.playerSpeed;
  y = Math.max(0, Math.min(scene.clientHeight - player.clientHeight, y));
  player.style.top = y + "px";

  // –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ –µ—Å—Ç—å –æ—Ç–≤–µ—Ç—ã
  if(!state.locked) spawnAnswersForQuestion();

  // –¥–≤–∏–∂–µ–Ω–∏–µ –æ—Ç–≤–µ—Ç–æ–≤ + —É–¥–∞–ª–µ–Ω–∏–µ —É—à–µ–¥—à–∏—Ö –∑–∞ —ç–∫—Ä–∞–Ω
  if(!state.locked){
    const leftLimit = -120; // —É—à—ë–ª –¥–∞–ª–µ–∫–æ
    for(const obj of state.active){
      const x = obj.el.offsetLeft - GAME_CONFIG.speed;
      obj.el.style.left = x + "px";
      checkCollision(obj);
    }

    // –µ—Å–ª–∏ –≤—Å–µ –æ—Ç–≤–µ—Ç—ã —É—à–ª–∏ –∑–∞ —ç–∫—Ä–∞–Ω ‚Äî —ç—Ç–æ "–ø—Ä–æ–ø—É—Å–∫"
    const stillOnScreen = state.active.filter(o=>{
      const x = o.el.offsetLeft;
      if(x < leftLimit){
        o.el.remove();
        return false;
      }
      return true;
    });
    const removedCount = state.active.length - stillOnScreen.length;
    state.active = stillOnScreen;

    if(removedCount > 0 && state.active.length === 0 && !state.locked){
      // ‚úÖ –ø—Ä–æ–ø—É—Å—Ç–∏–ª–∏ –≤—Å–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã -> —Å—á–∏—Ç–∞–µ–º –æ—à–∏–±–∫–æ–π –∏ –∏–¥—ë–º –¥–∞–ª—å—à–µ
      if(GAME_CONFIG.missCountsAsWrong){
        state.locked = true;
        applyWrong("–ü—Ä–æ–ø—É—Å–∫");
        clearAnswers();
        setTimeout(goNextQuestion, GAME_CONFIG.feedbackMs);
      } else {
        goNextQuestion();
      }
    }
  }

  raf = requestAnimationFrame(loop);
}

function restart(){
  final.classList.remove("show");
  if(raf) cancelAnimationFrame(raf);
  raf = null;

  initState();
  updateHUD();
  player.style.top = "50%";
  clearAnswers();
  spawnAnswersForQuestion();
  loop();
}

window.addEventListener("keydown", async (e)=>{
  keys[e.key]=true;
  if(!audioUnlocked) await unlockAudio();
});
window.addEventListener("keyup",(e)=>keys[e.key]=false);
window.addEventListener("pointerdown", async ()=>{ if(!audioUnlocked) await unlockAudio(); }, {passive:true});

// start
initState();
updateHUD();
player.style.top = "50%";
spawnAnswersForQuestion();
loop();
</script>
</body>
</html>
